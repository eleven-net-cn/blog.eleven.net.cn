<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Eleven 的博客</title>
  
  
  <link href="https://blog.eleven.net.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.eleven.net.cn/"/>
  <updated>2025-05-07T09:00:36.260Z</updated>
  <id>https://blog.eleven.net.cn/</id>
  
  <author>
    <name>eleven-net-cn</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>低代码核心实现 - 组件间数据和行为交互</title>
    <link href="https://blog.eleven.net.cn/2025/04/17/lowcode/core/behavior/"/>
    <id>https://blog.eleven.net.cn/2025/04/17/lowcode/core/behavior/</id>
    <published>2025-04-17T02:44:02.000Z</published>
    <updated>2025-05-07T09:00:36.260Z</updated>
    
    <content type="html"><![CDATA[<p>每一个组件可以对外提供：</p><ol><li>抛出可联动的数据</li><li>抛出可调用的方法</li><li>提供可监听的事件</li></ol><h3 id="抛出可联动的数据"><a href="#抛出可联动的数据" class="headerlink" title="抛出可联动的数据"></a>抛出可联动的数据</h3><p>每个组件可以向外抛出数据，应用会收集维护在全局存储，该数据应是可响应式的，在应用顶层通过 Provider 向下传递，每一个组件都可以读取到。</p><p>组件抛出的数据，在编辑器中拖动配置组件时，为了能够被其它组件使用，需要在该组件中预先定义好待抛出的数据。</p><pre><code class="typescript">export default defineComponent&lt;Options&gt;(&#123;  declarations: &#123;    // 此组件可联动的数据    linkState: &#123;      // 定义此组件会向外抛出”已预约人数“的数据      numFollowed: &#123;        label: &#39;已预约人数&#39;,        type: &#39;number&#39;,        default: 0,      &#125;,    &#125;,  &#125;,&#125;);</code></pre><p>组件实现中借助统一提供的函数抛出数据：</p><pre><code class="typescript">const num = await getFollowedNum(); // 示例从接口获取// 抛出函数由全局下发，内部实现时，需关联当前组件的唯一 ID 将其挂载到全局存储syncState(&#123;  numFollowed: num,&#125;);</code></pre><p>而其它组件可通过以下方式使用数据：</p><ol><li><p>自己的配置项，直接绑定来自于某组件下的某数据</p></li><li><p>配置联动目标组件的某项数据，当其”大于、小于、等于“目标值时，联动切换指定的状态</p></li></ol><h3 id="抛出可调用的方法"><a href="#抛出可调用的方法" class="headerlink" title="抛出可调用的方法"></a>抛出可调用的方法</h3><p>组件中定义可调用的方法名，及配置方法时的表单配置。</p><pre><code class="typescript">export default defineComponent&lt;Options&gt; (&#123;  declarations: &#123;    // 可被其它组件调用的方法    methods: [      &#123;        label: &#39;刷新列表&#39;,        name: &#39;refresh&#39;,        form: &#123;          label: &#39;刷新第几页&#39;          placeholder: &#39;请输入刷新第几页，若缺省默认刷新当前页&#39;        &#125;      &#125;    ]  &#125;&#125;)</code></pre><pre><code class="typescript">const refresh = () =&gt; &#123;&#125;;// 示例 Vue 的实现defineExpose(&#123;  refresh,&#125;);</code></pre><h3 id="提供可监听的事件"><a href="#提供可监听的事件" class="headerlink" title="提供可监听的事件"></a>提供可监听的事件</h3><pre><code class="typescript">export default defineComponent&lt;Options&gt;(&#123;  declarations: &#123;    // 可被其它组件监听的事件    events: [      &#123;        label: &#39;加载完成时&#39;,        name: &#39;loaded&#39;,      &#125;,    ],  &#125;,&#125;);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;每一个组件可以对外提供：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;抛出可联动的数据&lt;/li&gt;
&lt;li&gt;抛出可调用的方法&lt;/li&gt;
&lt;li&gt;提供可监听的事件&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;抛出可联动的数据&quot;&gt;&lt;a href=&quot;#抛出可联动的数据&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="LowCode" scheme="https://blog.eleven.net.cn/categories/LowCode/"/>
    
    
    <category term="LowCode" scheme="https://blog.eleven.net.cn/tags/LowCode/"/>
    
  </entry>
  
  <entry>
    <title>Vite 疑难杂症</title>
    <link href="https://blog.eleven.net.cn/2024/12/15/vite/qa/"/>
    <id>https://blog.eleven.net.cn/2024/12/15/vite/qa/</id>
    <published>2024-12-15T02:52:55.000Z</published>
    <updated>2025-05-07T09:00:36.261Z</updated>
    
    <content type="html"><![CDATA[<p>在 2022 年初投产了第一个 Vite 应用到产线，陆续处理的问题 Case，挑选一些记录下来。</p><p>若改造旧的 webpack 应用，推荐参照 <a href="https://github.com/originjs/webpack-to-vite/blob/main/README-zh.md">webpack-to-vite</a> 理解更多差异。</p><h2 id="应用中需要支持-require-语法"><a href="#应用中需要支持-require-语法" class="headerlink" title="应用中需要支持 require 语法"></a>应用中需要支持 <code>require</code> 语法</h2><p>应用代码中，通常不再建议使用 <code>require</code>，应当都替换为 <code>import</code>.</p><p>但是，若为迁移旧代码或其它原因，社区有多款插件可以选用。</p><p>简单的场景推荐：<a href="https://github.com/wangzongming/vite-plugin-require">https://github.com/wangzongming/vite-plugin-require</a></p><p>如果是三方依赖包的产物中包含了 <code>require()</code> 代码呢？</p><p>这种场景更加复杂一些，在 esbuild 预构建时可能遇到模块导出的值不符合预期，在调研对比多个社区方案后，推荐考虑使用以下插件：</p><p><a href="https://github.com/vite-plugin/vite-plugin-commonjs">https://github.com/vite-plugin/vite-plugin-commonjs</a></p><h2 id="lib-模式编译，如何引入-polyfill？"><a href="#lib-模式编译，如何引入-polyfill？" class="headerlink" title="lib 模式编译，如何引入 polyfill？"></a>lib 模式编译，如何引入 polyfill？</h2><p>在打包 App 应用时可以依靠 <a href="https://github.com/vitejs/vite/tree/main/packages/plugin-legacy">@vitejs/plugin-legacy</a> 处理 Polyfill，而 lib 模式编译类库时，不会引入 Polyfill。</p><p>推荐使用 Rollup 插件，通过 Babel 在最后阶段再处理 Polyfill。</p><pre><code class="typescript">import &#123; defineConfig &#125; from &#39;vite&#39;;import &#123; getBabelOutputPlugin &#125; from &#39;@rollup/plugin-babel&#39;;export default defineConfig(&#123;  build: &#123;    rollupOptions: &#123;      plugins: [        /**         * Running Babel on the generated code:         *  https://github.com/rollup/plugins/blob/master/packages/babel/README.md#running-babel-on-the-generated-code         *         * Transforming ES6+ syntax to ES5 is not supported yet, there are two ways to do:         *  https://github.com/evanw/esbuild/issues/1010#issuecomment-803865232         * We choose to run Babel on the output files after esbuild.         *         * @vitejs/plugin-legacy does not support library mode:         *  https://github.com/vitejs/vite/issues/1639         */        getBabelOutputPlugin(&#123;          allowAllFormats: true,          presets: [            [              &#39;@babel/preset-env&#39;,              &#123;                useBuiltIns: false,                exclude: [&#39;transform-typeof-symbol&#39;],                modules: false,              &#125;,            ],          ],          plugins: [            [              &#39;@babel/plugin-transform-runtime&#39;,              &#123;                corejs: false,                // version: require(&#39;@babel/runtime&#39;).version,              &#125;,            ],          ].filter(Boolean),        &#125;),      ],    &#125;,  &#125;,&#125;);</code></pre><h2 id="Vite-lib-模式打包时，静态资源会被内联（官方解释），如何处理？"><a href="#Vite-lib-模式打包时，静态资源会被内联（官方解释），如何处理？" class="headerlink" title="Vite lib 模式打包时，静态资源会被内联（官方解释），如何处理？"></a>Vite lib 模式打包时，静态资源会被内联（<a href="https://cn.vite.dev/config/build-options.html#build-assetsinlinelimit">官方解释</a>），如何处理？</h2><p>当我们使用 Vite 编译组件、类库时，此问题暴露尤其明显。例如组件中使用的某几张图片，留待使用该组件的应用打包应属最佳，否则，大量的图片被内联在 js 代码中，会严重影响加载速度。</p><p>在我们的场景下此问题十分重要，社区内没有可使用的方案，layne 同学编写了以下插件完美解决问题。</p><p><a href="https://github.com/laynezh/vite-plugin-lib-assets">https://github.com/laynezh/vite-plugin-lib-assets</a></p><ul><li><code>iife</code> 资源路径转拼接指定的 <code>publicUrl</code></li><li><code>esm</code> 转换为相对路径引入</li><li><code>commonjs</code> 转换为相对路径引入</li></ul><pre><code class="typescript">import &#123; defineConfig &#125; from &#39;vite&#39;;import assetsPlugin from &#39;@laynezh/vite-plugin-lib-assets&#39;;export default defineConfig(&#123;  plugins: [    assetsPlugin(&#123;      name: &#39;[name].[contenthash:8].[ext]&#39;,      limit: 1024 * 8,      publicUrl: undefined,    &#125;),  ],&#125;);</code></pre><h2 id="commonjs-模块中引用的资源应原样输出"><a href="#commonjs-模块中引用的资源应原样输出" class="headerlink" title="commonjs 模块中引用的资源应原样输出"></a>commonjs 模块中引用的资源应原样输出</h2><pre><code class="typescript">import &#123; defineConfig &#125; from &#39;vite&#39;;export default defineConfig(&#123;  build: &#123;    commonjsOptions: &#123;      /**       * https://github.com/rollup/plugins/tree/master/packages/commonjs#requirereturnsdefault       *       * require(&#39;./images/123.png&#39;) =&gt; import Img123 from &#39;./images/123.png&#39;       *       * and &#39;./images/123.png&#39; 会被 vite 处理成 base64 格式实现载入       */      requireReturnsDefault(id) &#123;        const [pureId] = id.split(&#39;?&#39;, 2);        return commonjsAssetsFilter(pureId);      &#125;,    &#125;,  &#125;,&#125;);</code></pre><h2 id="修改-lib-模式输出的样式文件名"><a href="#修改-lib-模式输出的样式文件名" class="headerlink" title="修改 lib 模式输出的样式文件名"></a>修改 lib 模式输出的样式文件名</h2><p>不同于修改 js 文件输出的名称，样式文件需要不一样的处理方式。</p><pre><code class="typescript">import defineConfig from &#39;vite&#39;;export default defineConfig(&#123;  build: &#123;    rollupOptions: &#123;      output: &#123;        assetFileNames(assetInfo) &#123;          // https://github.com/vitejs/vite/issues/4863          if (!ignoreStyles &amp;&amp; assetInfo.name === &#39;style.css&#39;) &#123;            return `$&#123;fileName&#125;.css`;          &#125;          return assetInfo.name;        &#125;,      &#125;,    &#125;,  &#125;,&#125;);</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在 2022 年初投产了第一个 Vite 应用到产线，陆续处理的问题 Case，挑选一些记录下来。&lt;/p&gt;
&lt;p&gt;若改造旧的 webpack 应用，推荐参照 &lt;a href=&quot;https://github.com/originjs/webpack-to-vite/blob/</summary>
      
    
    
    
    <category term="Vite" scheme="https://blog.eleven.net.cn/categories/Vite/"/>
    
    
    <category term="Vite" scheme="https://blog.eleven.net.cn/tags/Vite/"/>
    
  </entry>
  
  <entry>
    <title>前端依赖治理</title>
    <link href="https://blog.eleven.net.cn/2022/07/22/fe/dependency-cruiser/"/>
    <id>https://blog.eleven.net.cn/2022/07/22/fe/dependency-cruiser/</id>
    <published>2022-07-22T02:58:02.000Z</published>
    <updated>2025-05-07T09:00:36.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><blockquote><p>Validate and visualise dependencies. With your rules. JavaScript. TypeScript. CoffeeScript. ES6, CommonJS, AMD.</p></blockquote><p>dependency-cruiser，用于前端依赖模块的可视化和依赖的校验，支持使用定制的规则，支持前端常用的 JS、TS 语言以及 ES Module、CommonJS 等模块规范。</p><p>GitHub：<a href="https://github.com/sverweij/dependency-cruiser">https://github.com/sverweij/dependency-cruiser</a></p><h2 id="模块依赖可视化"><a href="#模块依赖可视化" class="headerlink" title="模块依赖可视化"></a>模块依赖可视化</h2><p>推荐作为阅读项目或开源库源码的辅助工具，更易理清项目内部的结构、依赖关系。</p><p>官方示例图</p><p><img src="https://static.eleven.net.cn/images/dependency-cruiser-archi-graph.svg" alt=""></p><p>官方示例图（React）</p><p><img src="https://static.eleven.net.cn/images/react-high-level-dependencies.svg" alt=""></p><p>更多示例：<a href="https://github.com/sverweij/dependency-cruiser/blob/develop/doc/real-world-samples.md">https://github.com/sverweij/dependency-cruiser/blob/develop/doc/real-world-samples.md</a></p><h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><p>推荐最简单的查看方式，安装 VS Code 插件 ☞ Dependency Cruiser Extension</p><p><img src="/imgs/dependency_cruiser_vscode_plugin.png" alt=""></p><p>安装好插件后，在 vscode 中目标项目目录上，点击右键 - “View Dependencies”，即可自动生成相关依赖分析图，示例如下。</p><h3 id="更多方式"><a href="#更多方式" class="headerlink" title="更多方式"></a>更多方式</h3><p>如果有更加具体的需求场景，也可以通过工具生成 svg 依赖关系图片，详细参照官方说明 <a href="https://github.com/sverweij/dependency-cruiser#show-stuff-to-your-grandma">https://github.com/sverweij/dependency-cruiser#show-stuff-to-your-grandma</a> 。</p><p>一般需要做这些事情：</p><ol><li><p>安装 graphviz，用来生成依赖关系图</p><pre><code class="bash">brew install graphviz</code></pre></li><li><p>在项目根目录下安装 dependency-cruiser</p><pre><code class="bash">npm i dependency-cruiser -D</code></pre></li><li><p>运行命令，生成 svg 依赖关系图片</p><pre><code class="bash">npx depcruise --include-only &quot;^src&quot; —output-type dot src | dot -T svg &gt; dependency-graph.svg</code></pre></li></ol><p>相关参数：</p><ul><li><p><code>-output-type dot</code> ：表示输出格式为 dot，意味着使用 Graphviz 来输出</p></li><li><p><code>dot -T svg &gt; dependency-graph.svg</code> ：为 Graphviz 的命令行语法，表示输出名为 dependency-graph 的 svg 文件</p></li><li><p><code>-exclude</code>：用于过滤掉图上不关心的依赖</p></li><li><p><code>-include-only</code>：与 –exclude 相反，只保留范围内的依赖</p></li><li><p><code>-do-not-follow</code>：会过滤掉某个依赖的后续依赖</p></li><li><p><code>-max-depth</code>：指定依赖树的深度</p></li></ul><h2 id="模块依赖校验"><a href="#模块依赖校验" class="headerlink" title="模块依赖校验"></a>模块依赖校验</h2><p>借助 dependency-cruiser 对项目的依赖关系做校验，根据指定的规则，或自定义的规则，规避项目中可能产生的问题风险。</p><p>在某些复杂场景，或有较多模块使用约定的项目，非常适合使用 dependency-cruiser 去做规则校验，限制不规范或危险的行为。</p><h3 id="使用方式-1"><a href="#使用方式-1" class="headerlink" title="使用方式"></a>使用方式</h3><ol><li><p>在项目中初始化配置文件</p><pre><code class="bash">npx -p dependency-cruiser depcruise --init</code></pre><p><img src="/imgs/dependency_cruiser_init.gif" alt=""></p><p>会在根目录下生成 .dependency-cruiser.js 配置文件</p></li><li><p>在项目中安装依赖</p><pre><code class="bash">npm i dependency-cruiser -D</code></pre></li><li><p>在 package.json 中添加命令</p><pre><code class="json">&#123;  &quot;scripts&quot;: &#123;    &quot;start&quot;: &quot;vite --port 4000&quot;,    &quot;build&quot;: &quot;vue-tsc --noEmit &amp;&amp; vite build&quot;,    &quot;preview&quot;: &quot;vite preview&quot;,  + &quot;lint&quot;: &quot;depcruise src --config .dependency-cruiser.cjs&quot;  &#125;,  +&quot;gitHooks&quot;: &#123;  + &quot;pre-commit&quot;: &quot;lint-staged --allow-empty&quot;  +&#125;,  + &quot;lint-staged&quot;: &#123;  +   &quot;src/**/*.&#123;js?(x),ts?(x)&#125;&quot;: [  +    &quot;yarn lint&quot;  +  ]  +&#125;&#125;</code></pre><p>添加命令 lint，随时运行校验。</p><p>推荐加入到 Git Hooks 中，例如：放到 pre-commit 阶段执行校验，未通过禁止提交代码。</p><p><img src="/imgs/dependency_cruiser_lint.png" alt=""></p><p>这里为了方便演示，Git Hooks 用的 yorkie，若使用 husky 则更换对应配置。</p></li></ol><h3 id="规则文件"><a href="#规则文件" class="headerlink" title="规则文件"></a>规则文件</h3><p>来看一下规则文件都有什么？</p><p>文件结构</p><pre><code class="js">// .dependency-cruiser.cjsmodule.exports = &#123;  forbidden: [ // 被禁止的规则列表    &#123;...&#125;, // 规则1    &#123;...&#125;, // 规则2    &#123;...&#125;, // 规则3    // ...  ],  options: &#123; // 工具层面的若干配置   // ...  &#125;&#125;</code></pre><h3 id="规则定义"><a href="#规则定义" class="headerlink" title="规则定义"></a>规则定义</h3><pre><code class="json">&#123;  // ----- 规则基本配置 -----  name: &#39;no-non-package-json&#39;, // 规则名称  severity: &#39;error&#39;, // 严重等级  comment: &quot;This module depends on an npm package that isn&#39;t in the &#39;dependencies&#39; section of your package.json. &quot; +        &quot;That&#39;s problematic as the package either (1) won&#39;t be available on live (2 - worse) will be &quot; +        &#39;available on live with an non-guaranteed version. Fix it by adding the package to the dependencies &#39; +        &#39;in your package.json.&#39;, // 规则描述  // ----- 规则内容 -----  from: &#123;&#125;, // 不填则表示所有引用 ☞ 哪些模块、目录会被限制  to: &#123; // 命中哪些规则限制    dependencyTypes: [ // 命中的规则      &#39;npm-no-pkg&#39;,      &#39;npm-unknown&#39;,    ],    pathNot: [], // 排除掉哪些  &#125;,&#125;,</code></pre><p>from 和 to 描述规则的具体内容，from 表示「依赖方」，to 表示「被依赖方」。</p><h3 id="常用规则"><a href="#常用规则" class="headerlink" title="常用规则"></a>常用规则</h3><p>常用规则基本都已默认内置在生成的配置文件中，根据需要去开启、关闭或修改匹配范围、规则即可。</p><ul><li><p>禁止循环引用 no-circular</p></li><li><p>禁止引用不存在的模块（幽灵依赖） not-to-unresolvable</p></li><li><p>检测未被使用的模块 no-orphans</p></li><li><p>禁止生产环境代码使用开发依赖 not-to-dev-dep</p></li><li><p>……</p></li></ul><h3 id="自定义规则"><a href="#自定义规则" class="headerlink" title="自定义规则"></a>自定义规则</h3><p>借助强大的可配置能力，几乎可以制定出任何想要的依赖限制规则，以下举几个栗子。</p><ol><li><p>指定范围禁止引用某些三方模块</p><pre><code class="json">&#123;  name: &#39;not-to-import-src-node&#39;,  comment: &#39;src/node 禁止引用的模块&#39;,  severity: &#39;error&#39;,  // from: &#123;&#125;, // 不填，所有引用  from: &#123;    path: &#39;^src/node&#39;,  &#125;,  to: &#123;    path: [      &#39;antd&#39;,      &#39;react-dnd&#39;,      &#39;react-dnd-html5-backend&#39;,      &#39;moment&#39;,    ],  &#125;,&#125;;</code></pre></li><li><p>禁止跨模块引用</p><p>限制 src 下某个大模块，只能引用模块内部依赖或公共模块</p><pre><code class="json">&#123;  // ----- 规则基本配置 -----  name: &#39;no-cross-module-import&#39;,  severity: &#39;error&#39;, // 严重等级  comment: &#39;禁止跨模块引用&#39;,  // ----- 规则内容 -----  from: &#123;    path: &#39;^src/pageA&#39;,  &#125;,  to: &#123;    pathNot: [      // 只能引入自己或公共的模块      &#39;^src/pageA&#39;,      &#39;^src/utils&#39;,    ]  &#125;,&#125;,</code></pre></li><li><p>叶子依赖禁止再依赖其它模块</p><p>例如，项目封装了某个模块，完全使用浏览器原生 API，禁止使用其它相关的社区依赖，可以做如下限制。</p><pre><code class="json">&#123;  // ----- 规则基本配置 -----  name: &#39;cookies-leaf&#39;,  comment: &#39;cookies 库不应该有其它依赖&#39;,  severity: &#39;error&#39;,  // ----- 规则内容 -----  from: &#123;    path: &#39;^src/libs/cookies&#39;,  &#125;,  to: &#123;&#125;, // 不能引用任何其它依赖&#125;,</code></pre></li></ol><h3 id="集成到-NodeJS-脚本"><a href="#集成到-NodeJS-脚本" class="headerlink" title="集成到 NodeJS 脚本"></a>集成到 NodeJS 脚本</h3><p><a href="https://github.com/sverweij/dependency-cruiser/blob/develop/doc/api.md">https://github.com/sverweij/dependency-cruiser/blob/develop/doc/api.md</a></p><p>对于一些较为复杂的项目，尤其有诸多规则限制的项目，考虑将其集成到脚本中做默认校验会，将是一个好选择。</p><pre><code class="typescript">import &#123; cruise &#125; from &quot;dependency-cruiser&quot;;import type &#123; IReporterOutput, ICruiseOptions &#125; from &quot;dependency-cruiser&quot;;const ARRAY_OF_FILES_AND_DIRS_TO_CRUISE: string[] = [&quot;src&quot;];const cruiseOptions: ICruiseOptions = &#123;  includeOnly: &quot;src&quot;,&#125;;try &#123;  const cruiseResult: IReporterOutput = cruise(    ARRAY_OF_FILES_AND_DIRS_TO_CRUISE,    cruiseOptions  );  console.dir(cruiseResult.output, &#123; depth: 10 &#125;);&#125; catch (error) &#123;  console.error(error);&#125;</code></pre><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ol><li><p>跟 ESLint 有什么区别么？</p><p>A：二者没有直接联系，一般推荐搭配起来一起使用。eslint 负责代码检查，dependency-cruiser 负责依赖检查。</p></li><li><p>能集成到 eslint 中，作为 eslint plugin 使用么？</p><p>A：暂时不能</p><ul><li><p>相关讨论：<a href="https://github.com/sverweij/dependency-cruiser/issues/529">https://github.com/sverweij/dependency-cruiser/issues/529</a></p></li><li><p>有人做了尝试：<a href="https://github.com/sverweij/eslint-plugin-budapestian">https://github.com/sverweij/eslint-plugin-budapestian</a></p></li></ul></li><li><p>能集成到 webpack 等编译工具中，达到编码中自动 watch 反馈的体验么？</p><p>A：暂时不能。主要是性能方面的考虑，不太适合提供这样的能力。</p></li></ol><p>更多问题的官方 FAQ：<a href="https://github.com/sverweij/dependency-cruiser/blob/develop/doc/faq.md">https://github.com/sverweij/dependency-cruiser/blob/develop/doc/faq.md</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Validate and visualise dependencies. With your rules. Jav</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vscode 调试技巧</title>
    <link href="https://blog.eleven.net.cn/2022/02/23/vscode/dev/"/>
    <id>https://blog.eleven.net.cn/2022/02/23/vscode/dev/</id>
    <published>2022-02-23T06:34:15.000Z</published>
    <updated>2025-05-07T09:00:36.261Z</updated>
    
    <content type="html"><![CDATA[<p>Web 开发中，大多数人都会习惯在浏览器端调试代码，而借助 vscode，可以带来不一样的调试体验，试想在代码编写处，直接打一个断点，实时 debugger，体验是不是更顺畅了一点？</p><p>以下简单介绍日常 SPA 单页应用、nodejs 应用的调试。</p><h2 id="调试-SPA-应用"><a href="#调试-SPA-应用" class="headerlink" title="调试 SPA 应用"></a>调试 SPA 应用</h2><h3 id="launch-模式"><a href="#launch-模式" class="headerlink" title="launch 模式"></a>launch 模式</h3><p>1、项目中添加调试配置</p><p>操作“运行 - 添加配置”，下拉选择 chrome 自动添加即可，根据需要修改参数值</p><p>示例如下：</p><pre><code class="JSON">&#123;  // 使用 IntelliSense 了解相关属性。  // 悬停以查看现有属性的描述。  // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387  &quot;version&quot;: &quot;0.2.0&quot;,  &quot;configurations&quot;: [    &#123;      &quot;name&quot;: &quot;Launch Chrome against localhost&quot;,      &quot;type&quot;: &quot;pwa-chrome&quot;,      &quot;request&quot;: &quot;launch&quot;,      // 默认启动 url      &quot;url&quot;: &quot;http://localhost:3000&quot;,      // 指定终端      &quot;console&quot;: &quot;integratedTerminal&quot;,      &quot;webRoot&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,      &quot;sourceMaps&quot;: true    &#125;  ]&#125;</code></pre><p>2、启动应用</p><p>3、按 <code>F5</code> 启动 vscode 调试，即可自动拉起 chrome 访问 url，开始调试。</p><h3 id="attach-模式"><a href="#attach-模式" class="headerlink" title="attach 模式"></a>attach 模式</h3><p>attach 模式不会自动拉起 chrome，可以自己选择访问，相比 launch 模式而言，自由度更高一点，并且已安装的浏览器插件可以使用（launch 模式不能）。</p><p>1、通过终端启动 chrome，指定 vscode 和 chrome 调试连接的端口（<code>--remote-debugging-port</code>），与下方配置中的 <code>port</code> 保持一致。</p><blockquote><p>命令行启动时，如果 chrome 已经在运行，需要 command + Q 先退出。</p></blockquote><pre><code class="Bash">/Applications/Google\ Chrome.app/Contents/MacOS/Google\ Chrome --remote-debugging-port=9222</code></pre><p>若未退出已有的 chrome，直接启动会失败，需要先退出再启动。</p><p>2、项目中添加调试配置</p><p>操作“运行 - 添加配置”，下拉选择 chrome 自动添加即可，根据需要修改参数值</p><p>示例如下：</p><pre><code class="JSON">&#123;  // 使用 IntelliSense 了解相关属性。  // 悬停以查看现有属性的描述。  // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387  &quot;version&quot;: &quot;0.2.0&quot;,  &quot;configurations&quot;: [    &#123;      &quot;name&quot;: &quot;Attach to Chrome&quot;,      &quot;type&quot;: &quot;pwa-chrome&quot;,      &quot;request&quot;: &quot;attach&quot;,      // vscode 与 chrome 调试的 websocket 端口      &quot;port&quot;: 9222,      // 指定终端      &quot;console&quot;: &quot;integratedTerminal&quot;,      &quot;webRoot&quot;: &quot;$&#123;workspaceFolder&#125;&quot;,      &quot;sourceMaps&quot;: true    &#125;  ]&#125;</code></pre><p>3、启动应用</p><p>4、按<code>F5</code> 启动 vscode 调试</p><p>5、在浏览器正常访问应用，即可在 vscode 中开始调试</p><h2 id="调试-nodejs-应用"><a href="#调试-nodejs-应用" class="headerlink" title="调试 nodejs 应用"></a>调试 nodejs 应用</h2><p>1、项目中添加调试配置</p><p>操作“运行 - 添加配置”，下拉选择 node 自动添加即可，根据需要修改参数值</p><p>示例如下：</p><pre><code class="JSON">&#123;  // 使用 IntelliSense 了解相关属性。  // 悬停以查看现有属性的描述。  // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387  &quot;version&quot;: &quot;0.2.0&quot;,  &quot;configurations&quot;: [    &#123;      &quot;type&quot;: &quot;pwa-node&quot;,      &quot;request&quot;: &quot;launch&quot;,      &quot;name&quot;: &quot;create-component-app&quot;,      &quot;console&quot;: &quot;integratedTerminal&quot;,      &quot;skipFiles&quot;: [&quot;&lt;node_internals&gt;/**&quot;],      // 运行当前文件开始调试      &quot;program&quot;: &quot;$&#123;file&#125;&quot;,      // 指定某个入口文件开始调试      // &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;/src/index.js&quot;    &#125;  ]&#125;</code></pre><p>2、按<code>F5</code> 开始调试</p><h2 id="备注"><a href="#备注" class="headerlink" title="备注"></a>备注</h2><ol><li><p>如果应用中同时配置了多个调试模式，建议通过点击“运行和调试”，先选择启动模式，再去启动调试。</p></li><li><p>launch.json 参数</p></li></ol><ul><li><code>name</code> - 当前调试配置项的名称，可读性要好，区分每个调试配置项</li><li><code>type</code> - 用于此启动配置的调试器的类型。每个已安装的调试扩展都引入一种类型：例如 node，php，go 等。</li><li><code>request</code> - 当前调试项的类型，目前支持 launch 和 attach 两种类型。launch 适合调试未启动的程序，attach 则适合调试已经运行的程序。</li><li><code>program</code>- 启动调试器时要运行的可执行程序或文件</li><li><code>args</code>- 传递给程序进行调试的参数</li><li><code>env</code> - 调试时的环境变量</li><li><code>envFile</code> - 包含环境变量键值对的文件</li><li><code>stopOnEntry</code> - 程序启动时立即中断</li><li><code>port</code> - 连接到正在运行的调试器的端口</li><li><code>runtimeExecutable</code> - 启用调试的可执行 Runtime，默认是 Node</li></ul><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p>更多强悍的调试能力，推荐阅读下方文档了解。</p><ol><li><a href="https://mp.weixin.qq.com/s/9gERuxNiJaWYUeie910ALA">这几个 JavaScript 断点调试技能你有必要掌握！</a></li><li><a href="https://juejin.cn/post/6844904199805730823#heading-0">Node.js 深度调试指南</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Web 开发中，大多数人都会习惯在浏览器端调试代码，而借助 vscode，可以带来不一样的调试体验，试想在代码编写处，直接打一个断点，实时 debugger，体验是不是更顺畅了一点？&lt;/p&gt;
&lt;p&gt;以下简单介绍日常 SPA 单页应用、nodejs 应用的调试。&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    <category term="VSCode" scheme="https://blog.eleven.net.cn/categories/VSCode/"/>
    
    
    <category term="调试，vscode， nodejs" scheme="https://blog.eleven.net.cn/tags/%E8%B0%83%E8%AF%95%EF%BC%8Cvscode%EF%BC%8C-nodejs/"/>
    
  </entry>
  
  <entry>
    <title>Charles 抓包/代理 websocket 请求</title>
    <link href="https://blog.eleven.net.cn/2021/05/29/charles/websocket/"/>
    <id>https://blog.eleven.net.cn/2021/05/29/charles/websocket/</id>
    <published>2021-05-29T11:13:25.000Z</published>
    <updated>2025-05-07T09:00:36.259Z</updated>
    
    <content type="html"><![CDATA[<p>Charles 中如何抓包、代理 websocket 请求？过程有些复杂、坑点颇多，这里提供一份可用的方案。</p><p>请先确保你的 charles 能够抓到浏览器的请求，通常你可能需要注意以下几类问题：</p><ul><li>确保已勾选 charles 的 <code>Proxy - macOS Proxy</code> 选项</li><li>浏览器推荐设置为“系统代理”，如果使用了某些浏览器的代理插件，请记得切换</li><li>是否已安装好 https 证书？</li><li>如果有使用某些 VPN 代理工具，可能会存在代理冲突。如果遇到了抓不到请求的问题，推荐先关掉 VPN 工具，随后重启 charles（重启比较重要，它会重置系统的网络代理配置）</li></ul><p>如果还有问题，推荐阅读这篇使用指南 ☞ <a href="https://blog.csdn.net/mxw2552261/article/details/78645118">传送门</a>。</p><p>保证能正常抓到请求，再继续向下去看怎么抓取 websocket，当前使用的 charles 版本是 v4.6.1。</p><h2 id="charles-需要开启若干设置"><a href="#charles-需要开启若干设置" class="headerlink" title="charles 需要开启若干设置"></a>charles 需要开启若干设置</h2><p>1、打开 Proxy - Proxy Settings，勾选 Enable SOCKS proxy，默认配置不必修改，如下图：</p><p><img src="/imgs/charles_01.png" alt=""></p><p>2、在 Proxy - Proxy Settings - macos 面板中，确保勾选 Use SOCKS proxy，如下图：</p><p><img src="/imgs/charles_02.png" alt=""></p><h2 id="Mac-的网络设置中勾选若干项"><a href="#Mac-的网络设置中勾选若干项" class="headerlink" title="Mac 的网络设置中勾选若干项"></a>Mac 的网络设置中勾选若干项</h2><p>确保勾选了 SOCKS 选项，如下图：</p><p><img src="/imgs/mac_01.png" alt=""></p><p><img src="/imgs/mac_02.png" alt=""></p><p>SOCKS 代理的端口 8889 是 charles 代理 websocket 的默认端口，一般情况下不要去修改它。</p><p>以上工作都完成，那么你应该可以愉快地抓取、代理 websockt 请求了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Charles 中如何抓包、代理 websocket 请求？过程有些复杂、坑点颇多，这里提供一份可用的方案。&lt;/p&gt;
&lt;p&gt;请先确保你的 charles 能够抓到浏览器的请求，通常你可能需要注意以下几类问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;确保已勾选 charles 的 &lt;co</summary>
      
    
    
    
    <category term="Charles" scheme="https://blog.eleven.net.cn/categories/Charles/"/>
    
    
    <category term="websocket" scheme="https://blog.eleven.net.cn/tags/websocket/"/>
    
  </entry>
  
  <entry>
    <title>Apple M1 芯片问题汇总</title>
    <link href="https://blog.eleven.net.cn/2021/04/14/mac/command/"/>
    <id>https://blog.eleven.net.cn/2021/04/14/mac/command/</id>
    <published>2021-04-14T05:24:43.000Z</published>
    <updated>2025-05-07T09:00:36.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用-Rosetta-打开"><a href="#使用-Rosetta-打开" class="headerlink" title="使用 Rosetta 打开"></a>使用 Rosetta 打开</h2><p><a href="https://www.macwk.com/article/apple-silicon-m1-application-crash-repair">https://www.macwk.com/article/apple-silicon-m1-application-crash-repair</a></p><h2 id="M1-Mac-nvm-安装-升级-卸载"><a href="#M1-Mac-nvm-安装-升级-卸载" class="headerlink" title="M1 Mac nvm 安装/升级/卸载"></a>M1 Mac nvm 安装/升级/卸载</h2><blockquote><p>最好能够翻墙，并且设置终端可翻墙，否则速度太慢可能断掉。</p></blockquote><ol><li><p>安装</p><p>对于 M1 芯片的 Mac，低版本的 nvm 使用存在一些奇怪的问题，需要卸载后重装最新版本。</p><pre><code class="zsh">curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.1/install.sh | bash</code></pre><p>安装完成后，修改 zsh 终端配置，打开配置文件：</p><pre><code class="zsh">open ~/.zshrc</code></pre><p>在配置文件尾部，添加如下代码：</p><pre><code class="zsh">export NVM_DIR=&quot;$HOME/.nvm&quot;[ -s &quot;$NVM_DIR/nvm.sh&quot; ] &amp;&amp; \. &quot;$NVM_DIR/nvm.sh&quot;  # This loads nvm[ -s &quot;$NVM_DIR/bash_completion&quot; ] &amp;&amp; \. &quot;$NVM_DIR/bash_completion&quot;  # This loads nvm bash_completion</code></pre><p>保存后关闭，并在终端运行下发命令，让配置生效。</p><pre><code class="zsh">source ~/.zshrc</code></pre><p>安装工作结束！</p></li><li><p>升级</p><p>切换到 nvm 安装目录</p><pre><code class="zsh">cd ~/.nvm</code></pre><p>直接操作拉取最新代码即可</p><pre><code class="zsh">git fetch</code></pre></li><li><p>卸载</p><p>移除 .nvm 目录即可，通常位置在 <code>~/.nvm</code></p><pre><code class="zsh">rm -rf ~/.nvm</code></pre></li></ol><p>参考文章：<a href="https://blog.csdn.net/longgege001/article/details/114067242">https://blog.csdn.net/longgege001/article/details/114067242</a></p><h2 id="M1-Mac-nvm-终端切换-x86-arm"><a href="#M1-Mac-nvm-终端切换-x86-arm" class="headerlink" title="M1 Mac nvm 终端切换 x86/arm"></a>M1 Mac nvm 终端切换 x86/arm</h2><pre><code class="zsh"># Check what version you&#39;re running:$ node --versionv14.15.4# Check architecture of the `node` binary:$ node -p process.archarm64# This confirms that the arch is for the M1 chip, which is causing the problems.# So we need to uninstall it.# We can&#39;t uninstall the version we are currently using, so switch to another version:$ nvm install v12.20.1# Now uninstall the version we want to replace:$ nvm uninstall v14.15.4# Launch a new zsh process under the 64-bit X86 architecture:$ arch -x86_64 zsh# Install node using nvm. This should download the precompiled x64 binary:$ nvm install v14.15.4# Now check that the architecture is correct:$ node -p process.archx64# It is now safe to return to the arm64 zsh process:$ exit# We&#39;re back to a native shell:$ archarm64# And the new version is now available to use:$ nvm use v14.15.4Now using node v14.15.4 (npm v6.14.10)</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;使用-Rosetta-打开&quot;&gt;&lt;a href=&quot;#使用-Rosetta-打开&quot; class=&quot;headerlink&quot; title=&quot;使用 Rosetta 打开&quot;&gt;&lt;/a&gt;使用 Rosetta 打开&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.macwk</summary>
      
    
    
    
    <category term="MacOS" scheme="https://blog.eleven.net.cn/categories/MacOS/"/>
    
    
    <category term="MacOS" scheme="https://blog.eleven.net.cn/tags/MacOS/"/>
    
  </entry>
  
  <entry>
    <title>Git 非常规问题记录</title>
    <link href="https://blog.eleven.net.cn/2021/04/07/git/questions/"/>
    <id>https://blog.eleven.net.cn/2021/04/07/git/questions/</id>
    <published>2021-04-07T07:35:52.000Z</published>
    <updated>2025-05-07T09:00:36.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="区分目录、remote-指定不同设置"><a href="#区分目录、remote-指定不同设置" class="headerlink" title="区分目录、remote 指定不同设置"></a>区分目录、remote 指定不同设置</h2><p>在区分企业与个人项目的提交信息时较为常用</p><pre><code class="zsh"># 推荐单独创建配置文件touch ~/.gitconfig-xx</code></pre><p>例如，需要单独设置 username/user-email</p><pre><code class="shell">[user]    name = xx    email = xxx@gmail.com</code></pre><pre><code class="zsh"># 打开 Git 默认的配置文件，添加指定目录下的规则open ~/.gitconfig</code></pre><h3 id="区分目录设置"><a href="#区分目录设置" class="headerlink" title="区分目录设置"></a>区分目录设置</h3><p>例如，指定 <code>~/xx/xx/</code> 目录使用上方创建的 <code>.gitconfig-xx</code> 配置，则在 <code>~/.gitconfig</code> 文件中添加如下配置：</p><pre><code class="zsh">[includeIf &quot;gitdir:~/xx/xx/&quot;]  path = ~/.gitconfig-xx</code></pre><h3 id="单独设置-GitHub"><a href="#单独设置-GitHub" class="headerlink" title="单独设置 GitHub"></a>单独设置 GitHub</h3><p>若仅对 GitHub 使用不同配置，推荐新建 <code>.gitconfig-github</code> 配置文件，在 <code>~/.gitconfig</code> 文件中添加如下配置：</p><pre><code class="zsh">[includeIf &quot;hasconfig:remote.*.url:git@github.com:*/**&quot;]    path = ~/.gitconfig-github</code></pre><h3 id="单独设置企业私有-GitLab"><a href="#单独设置企业私有-GitLab" class="headerlink" title="单独设置企业私有 GitLab"></a>单独设置企业私有 GitLab</h3><p>若仅对某域名的企业私有 GitLab 使用不同配置，推荐新建 <code>.gitconfig-xx</code> 配置文件，在 <code>~/.gitconfig</code> 文件中添加如下配置：</p><pre><code class="zsh"># xx.xxx.com 为示例的企业私有域名[includeIf &quot;hasconfig:remote.*.url:git@xx.xxx.com:*/**&quot;]    path = ~/.gitconfig-xx</code></pre><h2 id="与-fork-的上游仓库保持同步"><a href="#与-fork-的上游仓库保持同步" class="headerlink" title="与 fork 的上游仓库保持同步"></a>与 fork 的上游仓库保持同步</h2><p>一般有 3 种办法可用：</p><ol><li>命令行同步（安全，推荐）</li></ol><pre><code class="zsh">git remote -v# 将上游仓库添加进来git remote add upstream git@github.com:xxx/xxx.git# 拉取更新git fetch upstream# 合并过来git merge upstream/mastergit push origin master</code></pre><p>若干可以注意的地方，如下图：</p><p><img src="/imgs/git_fetch_fork_repo.png" alt=""></p><ol start="2"><li><p>借助第三方库：<a href="https://github.com/wei/pull">https://github.com/wei/pull</a> (如果自己有修改，会被覆盖。所以，比较适合仅参与 PR 的项目同步)</p></li><li><p>借助机器人程序 Backstroke：<a href="https://github.com/backstrokeapp/server">https://github.com/backstrokeapp/server</a></p></li></ol><h2 id="提示-hosts-问题"><a href="#提示-hosts-问题" class="headerlink" title="提示 hosts 问题"></a>提示 hosts 问题</h2><pre><code class="zsh">Warning:Permanently added the RSA host key for IP address &#39;13.229.188.59&#39; to the list of known hosts.</code></pre><p>遇到这种提示，多半是因为新机器刚配置的 git，或者常用的远程仓库更换了域名、IP 等。</p><p>可以将对应的域名、IP 配置进去，例如，将 github.com 添加进去，示例：</p><pre><code class="zsh">vi /etc/hostsinsert 13.229.188.59 github.com</code></pre><p>或者，删除 host 校验</p><pre><code class="zsh">rm -rf ~/.ssh/known_hosts # 删除后重新操作即可</code></pre><h2 id="Enter-passphrase-for-key-每次都需要输入密码"><a href="#Enter-passphrase-for-key-每次都需要输入密码" class="headerlink" title="Enter passphrase for key 每次都需要输入密码"></a>Enter passphrase for key 每次都需要输入密码</h2><pre><code class="zsh">ssh-add ~/.ssh/id_rsa</code></pre><h2 id="设置某文件、目录不被跟踪"><a href="#设置某文件、目录不被跟踪" class="headerlink" title="设置某文件、目录不被跟踪"></a>设置某文件、目录不被跟踪</h2><pre><code class="zsh">git update-index --assume-unchanged &lt;PATH&gt;</code></pre><p>对应的，允许某文件、目录被跟踪</p><pre><code class="zsh">git update-index --no-assume-unchanged &lt;PATH&gt;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;区分目录、remote-指定不同设置&quot;&gt;&lt;a href=&quot;#区分目录、remote-指定不同设置&quot; class=&quot;headerlink&quot; title=&quot;区分目录、remote 指定不同设置&quot;&gt;&lt;/a&gt;区分目录、remote 指定不同设置&lt;/h2&gt;&lt;p&gt;在区分企业与</summary>
      
    
    
    
    <category term="Git" scheme="https://blog.eleven.net.cn/categories/Git/"/>
    
    
    <category term="Git" scheme="https://blog.eleven.net.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>yarn workspaces 依赖安装报错</title>
    <link href="https://blog.eleven.net.cn/2021/04/07/yarn/workspaces-version/"/>
    <id>https://blog.eleven.net.cn/2021/04/07/yarn/workspaces-version/</id>
    <published>2021-04-07T07:29:52.000Z</published>
    <updated>2025-05-07T09:00:36.261Z</updated>
    
    <content type="html"><![CDATA[<p>yarn workspaces 结构的项目，在执行命令安装子包依赖时，可能会看到如下错误：</p><pre><code class="zsh">Failed to install dependencies in workspace: expected workspace package to exist</code></pre><p>yarn issues 下的相关问题讨论：<a href="https://github.com/yarnpkg/yarn/issues/7807">https://github.com/yarnpkg/yarn/issues/7807</a></p><p>目前比较简单的处理办法是降级 yarn 到 v1.18.0</p><pre><code class="zsh">yarn policies set-version 1.18.0</code></pre><p>后续还需要等待 yarn 官方来解决此问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;yarn workspaces 结构的项目，在执行命令安装子包依赖时，可能会看到如下错误：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;zsh&quot;&gt;Failed to install dependencies in workspace: expected workspace </summary>
      
    
    
    
    <category term="Yarn" scheme="https://blog.eleven.net.cn/categories/Yarn/"/>
    
    
    <category term="Yarn" scheme="https://blog.eleven.net.cn/tags/Yarn/"/>
    
    <category term="Yarn Workspaces" scheme="https://blog.eleven.net.cn/tags/Yarn-Workspaces/"/>
    
  </entry>
  
  <entry>
    <title>「转」H5直播流原理与实践方案</title>
    <link href="https://blog.eleven.net.cn/2021/03/28/video/live/"/>
    <id>https://blog.eleven.net.cn/2021/03/28/video/live/</id>
    <published>2021-03-28T04:22:05.000Z</published>
    <updated>2025-05-07T09:00:36.261Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转自 DuPei 同学的文档，这是比较全面的方案调研，转载分享给更多人，待将来需要时细细研究。</p></blockquote><h2 id="HLS-方案"><a href="#HLS-方案" class="headerlink" title="HLS 方案"></a>HLS 方案</h2><p>HLS 全称 HTTP Live Streaming，顾名思义是一个基于 HTTP 的流媒体传输协议。是由苹果公司提出，在苹果家族的整个产品都得到了比较好的支持，后来谷歌在 Chrome 浏览器和移动端浏览器也进行了原生支持，所以目前无论你是在 PC 还是移动端的浏览器基本都原生支持 HLS 协议进行播放视频，算是一个在移动端比较好的跨平台方案，同时微信内嵌的浏览器也都是原生支持的。</p><p>它允许用户从不同的备用源以不同的速率下载同样的资源片段。允许流媒体会话适应不同的数据速率。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>它的工作原理是把整个流切分成一片片小的基于 HTTP 的文件来下载。<br>浏览器使用的是 m3u8 文件，可以简单的认为 m3u8 就是包含多个 ts 文件的播放列表。播放器按顺序逐个播放，全部放完再请求一下 m3u8 文件，获得包含最新 ts 文件的播放列表继续播，周而复始。整个直播过程就是依靠一个不断更新的 m3u8 和一堆小的 ts 文件组成，m3u8 必须动态更新，ts 可以走 CDN。</p><p><img src="/imgs/video_live_hls.png" alt=""></p><h3 id="流说明"><a href="#流说明" class="headerlink" title="流说明"></a>流说明</h3><p>切片流，需要不断去请求新的 ts 文件才能续播。</p><ul><li>视频的封装格式是 TS。</li><li>视频的编码格式为 H264,音频编码格式为 MP3、AAC 或者 AC-3。</li><li>除了 TS 视频文件本身，还定义了用来控制播放的 m3u8 文件（文本文件）</li></ul><p>m3u8 文件包含的内容如下：</p><ul><li>EXTM3U<br>每一个 m3u8 文件开头必须为这个 tag，用作标示。</li><li>EXT-X-VERSION<br>用于标示版本，当前版本为 3，有且只能有一个，默认为 1。</li><li>EXT-X-TARGETDURATION<br>每一片的最大长度，部分 iphone 设备此参数不正确会导致无法播放。</li><li>EXT-X-MEDIA-SEQUENCE<br>切片的开始序号，且每一片的序号具有唯一性，相邻序号递增以保持流的连续性。</li><li>EXTINF<br>切片的实际时长。</li><li>EXT-X-PLAYLIST-TYPE<br>类型</li><li>EXT-X-ENDLIST<br>结束符号。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>兼容性很不错，尤其是在移动端，可作为兜底方案。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ol><li>延时比较大。由于 HLS 协议本身的切片原理，基本延迟都在 10s 以上。</li><li>文件碎片，ts 切片较小，会造成海量文件，对存储和缓存都有一定的挑战。</li></ol><h2 id="HTTP-FLV-方案"><a href="#HTTP-FLV-方案" class="headerlink" title="HTTP FLV 方案"></a>HTTP FLV 方案</h2><p>HTTP-FLV 即将流媒体数据封装成 FLV 格式，然后通过 HTTP 协议传输给客户端。</p><p>播放的能力基于 Media Source Extensions(MSE)，是一个 W3C 草案，MSE 扩展了 HTML5 的 Video 和 Audio 标签能力，允许开发者通过 JS 来从服务端拉流提供到 HTML5 的 Video 和 Audio 标签进行播放。</p><p><a href="https://caniuse.com/?search=Media%20Source%20Extensions">目前 MSE 的兼容情况</a></p><h3 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h3><p>MSE 目前支持的视频封装格式是 MP4，支持的视频编码是 H.264 和 MPEG4，支持的音频编码是 AAC 和 MP3。<br>封装格式的处理</p><ol><li>从服务端拉裸流(flv)过来，在前端将 flv 合成 MP4 片段进行播放。</li><li>在服务端提前转封装好成 MP4 格式传输，在前端直接通过 MSE 接口来播放。</li></ol><h3 id="流说明-1"><a href="#流说明-1" class="headerlink" title="流说明"></a>流说明</h3><p>连续流。</p><p>一般方案都是服务端经摄像头推流转成 FLV，然后客户端拉流，拉过来的流解封装为 FLV，然后再转成 MP4 片段，再经由 MSE 播放即可。<br>这个解封装和转为 mp4 格式的过程，<a href="https://github.com/bilibili/flv.js">flv.js</a> 帮忙实现了。</p><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p>延时低。</p><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p>移动端的兼容性不好，iOS Safari 浏览器没有支持，部分低版本的 iOS 微信端也不支持。</p><h2 id="RTMP-方案"><a href="#RTMP-方案" class="headerlink" title="RTMP 方案"></a>RTMP 方案</h2><p>Real Time Messaging Protocol（简称 RTMP）是 Macromedia 开发的一套视频直播协议，现在属于 Adobe。</p><p>基于 TCP 协议传输，这套方案需要搭建专门的 RTMP 流媒体服务如 Adobe Media Server，并且在浏览器中只能使用 Flash 实现播放器。它的实时性非常好，延迟很小，<strong>但无法支持移动端 WEB 播放是它的硬伤</strong>。</p><p>浏览器端，HTML5 video 标签无法播放 RTMP 协议的视频，可以通过 video.js 来实现。<a href="https://blog.csdn.net/impingo/article/details/103077380?spm=1001.2014.3001.5502">https://blog.csdn.net/impingo/article/details/103077380?spm=1001.2014.3001.5502</a></p><h2 id="以上三种方案比较"><a href="#以上三种方案比较" class="headerlink" title="以上三种方案比较"></a>以上三种方案比较</h2><table><thead><tr><th></th><th>Http flv</th><th>rtmp</th><th>hls</th></tr></thead><tbody><tr><td>传输协议</td><td>http</td><td>tcp</td><td>http</td></tr><tr><td>视频封装格式</td><td>flv</td><td>Flv tag</td><td>ts</td></tr><tr><td>延时</td><td>低</td><td>低</td><td>高</td></tr><tr><td>数据分段</td><td>连续流</td><td>连续流</td><td>切片文件</td></tr><tr><td>Html5 播放</td><td>可通过 h5 解封数据包播放 flv.js</td><td>不支持</td><td>可通过 h5 解封数据包播放 hls.js</td></tr></tbody></table><h2 id="其它方案"><a href="#其它方案" class="headerlink" title="其它方案"></a>其它方案</h2><h3 id="WebRTC-方案"><a href="#WebRTC-方案" class="headerlink" title="WebRTC 方案"></a>WebRTC 方案</h3><p>WebRTC 是一整套 API，其中一部分供 Web 开发者使用，另外一部分属于要求浏览器厂商实现的接口规范。WebRTC 解决诸如客户端流媒体发送、点对点通信、视频编码等问题。<br>桌面浏览器对 WebRTC 的支持较好，WebRTC 也很容易和 Native 应用集成。</p><h3 id="WebSocket-FLV"><a href="#WebSocket-FLV" class="headerlink" title="WebSocket-FLV"></a>WebSocket-FLV</h3><p>基于 WebSocket 传输 FLV，依赖浏览器支持播放 FLV。<br>WebSocket 建立在 HTTP 之上，建立 WebSocket 连接前还要先建立 HTTP 连接。</p><h3 id="RTP"><a href="#RTP" class="headerlink" title="RTP"></a>RTP</h3><p>基于 UDP，延迟 1 秒，浏览器不支持。</p><h2 id="清晰度切换支持"><a href="#清晰度切换支持" class="headerlink" title="清晰度切换支持"></a>清晰度切换支持</h2><p><a href="https://cloud.tencent.com/document/product/454/7503#.E5.8A.9F.E8.83.BD.E4.BB.8B.E7.BB.8D">清晰度切换支持</a></p><p><strong>播放器本身是没有能力去改变视频清晰度的</strong>，视频源只有一种清晰度，称之为原画，而原画视频的编码格式和封装格式多种，Web 端无法支持播放所有的视频格式，如点播支持以 H.264 为视频编码，MP4 和 FLV 为封装格式的视频。</p><p>多清晰度的实现依赖于服务端，进行实时转码，分出多路转码后的视频。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;转自 DuPei 同学的文档，这是比较全面的方案调研，转载分享给更多人，待将来需要时细细研究。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;HLS-方案&quot;&gt;&lt;a href=&quot;#HLS-方案&quot; class=&quot;headerlink&quot; title</summary>
      
    
    
    
    <category term="Video" scheme="https://blog.eleven.net.cn/categories/Video/"/>
    
    
    <category term="直播" scheme="https://blog.eleven.net.cn/tags/%E7%9B%B4%E6%92%AD/"/>
    
    <category term="Video" scheme="https://blog.eleven.net.cn/tags/Video/"/>
    
    <category term="Live" scheme="https://blog.eleven.net.cn/tags/Live/"/>
    
  </entry>
  
  <entry>
    <title>如何管理应用内的请求?</title>
    <link href="https://blog.eleven.net.cn/2021/03/27/react/query/"/>
    <id>https://blog.eleven.net.cn/2021/03/27/react/query/</id>
    <published>2021-03-27T10:01:48.000Z</published>
    <updated>2025-05-07T09:00:36.261Z</updated>
    
    <content type="html"><![CDATA[<p>如何管理应用内的接口请求？</p><p>这是一个值得讨论的问题，涉及如下若干方面：</p><ol><li>避免多次调用同一个请求（不同页面或不同组件）？</li><li>失败了自动重试？</li><li>切换浏览器 tab 返回页面时，自动发送请求更新数据？</li><li>列表滚动位置恢复？</li><li>…….</li></ol><p>这些问题可以在以下几个社区方案里找到答案（react-query 似乎更胜一筹）：</p><ul><li>reacrt-query：<a href="https://zhuanlan.zhihu.com/p/261146977">https://zhuanlan.zhihu.com/p/261146977</a></li><li>swr：<a href="https://swr.vercel.app/zh-CN">https://swr.vercel.app/zh-CN</a></li><li>ahooks/useRequest：<a href="https://ahooks.js.org/zh-CN/hooks/async">https://ahooks.js.org/zh-CN/hooks/async</a></li></ul><p>许多人会将多处使用的接口数据，存储到 Redux 等全局状态去管理，以减少重复的请求。理论上来说这是不合理的，状态管理会因此而变得混乱、臃肿，也给代码编写带来了额外的负担。</p><p>使用以上方案后，类库内部自动管理接口数据的状态，暂且称之为“服务端状态”，在任意的页面、组件都可以保持相同的 Hooks 方式调用，而全局只会发送一次请求，因此，状态管理需要存储的数据可以大幅减少。除此之外，还有自动重试、切屏更新数据等强大的封装功能，是日常应用开发的利器。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如何管理应用内的接口请求？&lt;/p&gt;
&lt;p&gt;这是一个值得讨论的问题，涉及如下若干方面：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;避免多次调用同一个请求（不同页面或不同组件）？&lt;/li&gt;
&lt;li&gt;失败了自动重试？&lt;/li&gt;
&lt;li&gt;切换浏览器 tab 返回页面时，自动发送请求更新数据？&lt;/l</summary>
      
    
    
    
    <category term="React" scheme="https://blog.eleven.net.cn/categories/React/"/>
    
    
    <category term="React" scheme="https://blog.eleven.net.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Babel 编译误伤 core-js？</title>
    <link href="https://blog.eleven.net.cn/2021/03/26/core-js/babel-compile/"/>
    <id>https://blog.eleven.net.cn/2021/03/26/core-js/babel-compile/</id>
    <published>2021-03-26T11:46:28.000Z</published>
    <updated>2025-05-07T09:00:36.259Z</updated>
    
    <content type="html"><![CDATA[<p>一个不太常见，但很重要的 core-js bug 讨论：<a href="https://github.com/zloirock/core-js/issues/514">https://github.com/zloirock/core-js/issues/514</a></p><h2 id="问题现象"><a href="#问题现象" class="headerlink" title="问题现象"></a>问题现象</h2><p>core-js 是 es3 的代码，应当是不需要 babel 编译的，但是，因为某种原因（暂不清楚），babel 会对 core-js 进行处理，并且会影响其中的代码，进而会发现 Symbol 在 Android 6.0 等低版本浏览器的兼容性出问题。</p><p>在移动端页面，小伙伴实际遭遇到了这种现象，依赖的第三方包使用了 Symbol 语法，即使引入全量的 core-js，依然无法解决兼容性报错问题，最终小伙伴追踪到了上方的 github issues。</p><h2 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h2><p>暂时需要手动将 core-js 添加到 <code>babel-loader</code> 的 <code>exclude</code> 配置中，指定 babel 不要去处理它。</p><pre><code class="js">/** * Babel 编译时，会处理 core-js（未来可能会被修复）， * 导致 polyfill 内部代码发生了变化，产生一些微小的影响，如 Symbol 问题。 * 暂时我们手动声明略过。 * https://github.com/zloirock/core-js/issues/514 * https://github.com/rails/webpacker/pull/2031 */exclude: [  /node_modules[\\/]core-js/,],</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;一个不太常见，但很重要的 core-js bug 讨论：&lt;a href=&quot;https://github.com/zloirock/core-js/issues/514&quot;&gt;https://github.com/zloirock/core-js/issues/514&lt;/a&gt;&lt;/</summary>
      
    
    
    
    <category term="Babel" scheme="https://blog.eleven.net.cn/categories/Babel/"/>
    
    
    <category term="Babel" scheme="https://blog.eleven.net.cn/tags/Babel/"/>
    
    <category term="Webpack" scheme="https://blog.eleven.net.cn/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>无 eject 重写 CRA 配置 — Craco 详解</title>
    <link href="https://blog.eleven.net.cn/2020/09/11/cra/craco/"/>
    <id>https://blog.eleven.net.cn/2020/09/11/cra/craco/</id>
    <published>2020-09-11T08:43:40.000Z</published>
    <updated>2025-05-07T09:00:36.260Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>内置 craco 扩展配置的 CRA Template，可直接使用。<br>TS 版本：<a href="https://www.npmjs.com/package/@eleven.fe/cra-template-typescript">@eleven.fe/cra-template-typescript</a><br>ES 版本：<a href="https://www.npmjs.com/package/@eleven.fe/cra-template">@eleven.fe/cra-template</a></p></blockquote><p>使用 CRA 脚手架创建的项目，如果想要修改编译配置，通常可能会选择 <code>npm run eject</code> 弹出配置后魔改。但是，eject 是不可逆操作，弹出配置后，你将无法跟随官方的脚步去升级项目的 react-scripts 版本。</p><p>如果想要无 eject 重写 CRA 配置，一般可以有以下几种方式</p><ol><li>通过 CRA 官方支持的 <code>--scripts-version</code> 参数，创建项目时使用自己重写过的 react-scripts 包</li><li>使用 <a href="https://github.com/timarney/react-app-rewired">react-app-rewired</a> + <a href="https://github.com/arackaf/customize-cra">customize-cra</a> 组合覆盖配置</li><li>使用 <a href="https://github.com/gsoft-inc/craco">craco</a> 覆盖配置</li></ol><p>第一种方式很棒，但这里暂时不做讨论，感兴趣的可以从下方链接了解更多：</p><ol><li>CRA 官方的介绍：<a href="https://create-react-app.dev/docs/alternatives-to-ejecting/">Alternatives to Ejecting</a></li><li><a href="https://auth0.com/blog/how-to-configure-create-react-app/">Customizing create-react-app: How to Make Your Own Template</a></li></ol><p>第二种方式相对第三种略复杂一些，并且我注意到 AntDesign 官方也开始推荐 <a href="https://github.com/gsoft-inc/craco">craco</a> 了，这里详细讨论一下第三种 <a href="https://github.com/gsoft-inc/craco">craco</a> 的使用，经过项目的实测，用起来还算顺手。</p><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><ol><li><p>安装包</p><pre><code class="sh">yarn add @craco/craco</code></pre></li><li><p>项目根目录创建 <code>craco.config.js</code> 文件</p><pre><code class="js">/* craco.config.js */module.exports = &#123;  ...&#125;</code></pre></li><li><p>修改 package.json 的 scripts 命令</p><pre><code class="json">/* package.json */&quot;scripts&quot;: &#123;-   &quot;start&quot;: &quot;react-scripts start&quot;,+   &quot;start&quot;: &quot;craco start&quot;,-   &quot;build&quot;: &quot;react-scripts build&quot;,+   &quot;build&quot;: &quot;craco build&quot;-   &quot;test&quot;: &quot;react-scripts test&quot;,+   &quot;test&quot;: &quot;craco test&quot;&#125;</code></pre></li></ol><p>基础的配置到此完成了，接下来是处理各种配置的覆盖，完整的 craco.config.js 配置文件结构，可以在 craco 官方的文档中详细查询：<a href="https://github.com/gsoft-inc/craco/blob/master/packages/craco/README.md#configuration-overview">Configuration Overview</a> 。</p><h2 id="区分环境"><a href="#区分环境" class="headerlink" title="区分环境"></a>区分环境</h2><p>@craco/craco 提供了 <code>whenDev、whenProd、whenTest、when</code> 函数，用于在书写 craco.config.js 配置文件时根据不同的编译环境确定配置，先看一下 craco 相关的源码：</p><pre><code class="js">function when(condition, fct, unmetValue) &#123;  if (condition) &#123;    return fct();  &#125;  return unmetValue;&#125;function whenDev(fct, unmetValue) &#123;  return when(process.env.NODE_ENV === &#39;development&#39;, fct, unmetValue);&#125;function whenProd(fct, unmetValue) &#123;  return when(process.env.NODE_ENV === &#39;production&#39;, fct, unmetValue);&#125;function whenTest(fct, unmetValue) &#123;  return when(process.env.NODE_ENV === &#39;test&#39;, fct, unmetValue);&#125;module.exports = &#123;  when,  whenDev,  whenProd,  whenTest,&#125;;</code></pre><ul><li><p><code>whenDev、whenProd、whenTest</code> 分别对应的是 <code>process.env.NODE_ENV</code> 的 3 种值（<code>development</code>、<code>production</code>、<code>test</code>），接收两个参数：</p><ul><li>第一个参数是 function，对应该编译环境下，执行函数，函数一般应当将需要的配置作为返回值。</li><li>第二个参数是默认值，非指定编译环境时，返回该默认值。</li></ul></li><li><p><code>when</code> 是区分环境的万金油函数，接收 3 个参数：</p><ul><li>第一个参数是判断的变量。</li><li>第二个参数是 function，参数一的变量为 true 时，执行该函数，函数一般应当将需要的配置作为返回值。</li><li>第三个参数是默认值，参数一的变量为 false 时，返回该默认值。</li></ul></li></ul><p>引用方式：</p><pre><code class="js">const &#123; whenDev, whenProd, when &#125; = require(&#39;@craco/craco&#39;);</code></pre><p>下方的示例中有多处使用，可以参照了解其用途。</p><h2 id="常用配置"><a href="#常用配置" class="headerlink" title="常用配置"></a>常用配置</h2><p>craco 有提供一些 <a href="https://github.com/gsoft-inc/craco#community-maintained-plugins">plugins</a>，集成了诸多功能，让覆盖配置变得更加容易。</p><p>除此之外，则需要我们对 webpack 的配置有一定的了解，根据 craco.config.js 的文件结构去增加配置。</p><h3 id="通过-configure-函数扩展-webpack-配置"><a href="#通过-configure-函数扩展-webpack-配置" class="headerlink" title="通过 configure 函数扩展 webpack 配置"></a>通过 configure 函数扩展 webpack 配置</h3><p>几乎所有的 webpack 配置均可以在 configure 函数中读取、覆盖，webpack 详细的配置参数结构可以查阅 webpack 官方的文档：<a href="https://webpack.js.org/configuration/">https://webpack.js.org/configuration/</a> 。</p><p>需要注意一点，configure 既可以定义为对象，也可以定义为函数，使用过程中，我发现二者是互斥的关系。这里推荐使用函数形式，因为当我想要覆盖 <code>mini-css-extract-plugin</code> 的配置时，发现对象形式的 configure 定义，不能达到目的。</p><p>configure 可以扩展所有的 webpack 配置，你可以将所有的配置都在 configure 中写完，但是，craco 提供了若干快捷的方式去定义指定的配置，例如：babel、alias、webpack 的 plugins 等。因此，推荐有快捷的方式尽量用快捷方式，搞不定的才放到 configure 中去定义。</p><pre><code class="js">/* craco.config.js */const &#123; whenDev, whenProd, when &#125; = require(&#39;@craco/craco&#39;);module.exports = &#123;  babel: &#123;&#125;,  webpack: &#123;    /**     * 重写 webpack 任意配置     *  - 与直接定义 configure 对象方式互斥     *  - 几乎所有的 webpack 配置均可以在 configure 函数中读取，然后覆盖     */    configure: (webpackConfig, &#123; env, paths &#125;) =&gt; &#123;      // 修改 output      webpackConfig.output = &#123;        ...webpackConfig.output,        ...&#123;          filename: whenDev(() =&gt; &#39;static/js/bundle.js&#39;, &#39;static/js/[name].js&#39;),          chunkFilename: &#39;static/js/[name].js&#39;,        &#125;,      &#125;;      // 关闭 devtool      webpackConfig.devtool = false;      // 配置扩展扩展名      webpackConfig.resolve.extensions = [        ...webpackConfig.resolve.extensions,        ...[&#39;.scss&#39;, &#39;.less&#39;],      ];      // 配置 splitChunks      webpackConfig.optimization.splitChunks = &#123;        ...webpackConfig.optimization.splitChunks,        ...&#123;          chunks: &#39;all&#39;,          name: true,        &#125;,      &#125;;      // 覆盖已经内置的 plugin 配置      webpackConfig.plugins.map((plugin) =&gt; &#123;        whenProd(() =&gt; &#123;          if (plugin instanceof MiniCssExtractPlugin) &#123;            Object.assign(plugin.options, &#123;              filename: &#39;static/css/[name].css&#39;,              chunkFilename: &#39;static/css/[name].css&#39;,            &#125;);          &#125;        &#125;);        return plugin;      &#125;);      return webpackConfig;    &#125;,  &#125;,&#125;;</code></pre><h3 id="扩展-babel-配置"><a href="#扩展-babel-配置" class="headerlink" title="扩展 babel 配置"></a>扩展 babel 配置</h3><p>虽然可以在 configure 中定义 babel 配置，但 craco 也提供了快捷的方式单独去书写，添加 <code>@babel/preset-env</code> 配置示例如下：</p><pre><code class="js">/* craco.config.js */module.exports = &#123;  babel: &#123;    presets: [      [        &#39;@babel/preset-env&#39;,        &#123;          modules: false, // 对ES6的模块文件不做转化，以便使用tree shaking、sideEffects等          useBuiltIns: &#39;entry&#39;, // browserslist环境不支持的所有垫片都导入          // https://babeljs.io/docs/en/babel-preset-env#usebuiltins          // https://github.com/zloirock/core-js/blob/master/docs/2019-03-19-core-js-3-babel-and-a-look-into-the-future.md          corejs: &#123;            version: 3, // 使用core-js@3            proposals: true,          &#125;,        &#125;,      ],    ],    plugins: [],  &#125;,&#125;;</code></pre><p>更详细的 babel 相关配置，推荐我之前整理的：<a href="https://webpack.eleven.net.cn/content/babel/">https://webpack.eleven.net.cn/content/babel/</a> 。</p><h3 id="扩展-webpack-alias（别名）"><a href="#扩展-webpack-alias（别名）" class="headerlink" title="扩展 webpack alias（别名）"></a>扩展 webpack alias（别名）</h3><p>虽然可以在 configure 中定义 alias，但 craco 也提供了快捷的方式单独去书写。</p><pre><code class="js">/* craco.config.js */module.exports = &#123;  babel: &#123;&#125;,  webpack: &#123;    configure: (webpackConfig, &#123; env, paths &#125;) =&gt; &#123;&#125;,    alias: &#123;      &#39;@&#39;: path.resolve(__dirname, &#39;src&#39;),    &#125;,  &#125;,&#125;;</code></pre><p>这里有一个坑点，如果你使用的是 cra 创建的 typescript 项目，添加完 alias 后，你还需要在 tsconfig.json 文件中新增配置，否则会提示出错。并且，新版本 cra 创建的项目，在编译时会自动格式化 tsconfig.json，你向里面添加的若干配置，可能会自动被清除掉。</p><p>怎么办？这里寻找到一个机智的办法，利用 tsconfig 的 extends 参数去扩展需要的配置。</p><p>tsconfig.json</p><pre><code class="json">&#123;  &quot;extends&quot;: &quot;./tsconfig.edit.json&quot;,  &quot;compilerOptions&quot;: &#123;    &quot;target&quot;: &quot;es5&quot;,    &quot;lib&quot;: [&quot;dom&quot;, &quot;dom.iterable&quot;, &quot;esnext&quot;],    &quot;allowJs&quot;: true,    &quot;skipLibCheck&quot;: true,    &quot;esModuleInterop&quot;: true,    &quot;allowSyntheticDefaultImports&quot;: true,    &quot;strict&quot;: true,    &quot;forceConsistentCasingInFileNames&quot;: true,    &quot;module&quot;: &quot;esnext&quot;,    &quot;moduleResolution&quot;: &quot;node&quot;,    &quot;resolveJsonModule&quot;: true,    &quot;isolatedModules&quot;: true,    &quot;noEmit&quot;: true,    &quot;jsx&quot;: &quot;react&quot;  &#125;,  &quot;include&quot;: [&quot;src&quot;]&#125;</code></pre><p>tsconfig.edit.json</p><pre><code class="json">&#123;  &quot;compilerOptions&quot;: &#123;    &quot;baseUrl&quot;: &quot;.&quot;,    &quot;paths&quot;: &#123;      &quot;@/*&quot;: [&quot;src/*&quot;]    &#125;  &#125;&#125;</code></pre><p>通过继承的方式，添加如上配置，alias 修改即可完成。</p><p>另外，craco 也提供了一个 plugin 专门用于修改 alias，以及处理 tsconfig 的问题，<a href="https://github.com/risenforces/craco-alias">传送门</a>，该页面下方的 Examples 中，详细说明了 tsconfig 的方案，推荐使用。</p><h3 id="新增-webpack-plugins"><a href="#新增-webpack-plugins" class="headerlink" title="新增 webpack plugins"></a>新增 webpack plugins</h3><p>如果想要新增一些 webpack plugins，可以直接在与 configure 平级的位置添加。当然，你在 configure 里添加也可以，但不推荐。</p><p>需要注意的是，如果你想修改内置的某些 webpack plugin 参数，必须到 configure 里去修改，示例见上方的 configure 介绍。</p><p>示例如下：</p><pre><code class="js">/* craco.config.js */const &#123; whenDev, whenProd, when &#125; = require(&#39;@craco/craco&#39;);const CircularDependencyPlugin = require(&#39;circular-dependency-plugin&#39;);const &#123; BundleAnalyzerPlugin &#125; = require(&#39;webpack-bundle-analyzer&#39;);module.exports = &#123;  babel: &#123;&#125;,  webpack: &#123;    configure: (webpackConfig, &#123; env, paths &#125;) =&gt; &#123;&#125;,    alias: &#123;      &#39;@&#39;: path.resolve(__dirname, &#39;src&#39;),    &#125;,    plugins: [      // 新增 webpack plugin      // 新增模块循环依赖检测插件      ...whenDev(        () =&gt; [          new CircularDependencyPlugin(&#123;            exclude: /node_modules/,            include: /src/,            failOnError: true,            allowAsyncCycles: false,            cwd: process.cwd(),          &#125;),        ],        [],      ),      // 新增打包产物分析插件      ...whenProd(        () =&gt; [          // https://www.npmjs.com/package/webpack-bundle-analyzer          new BundleAnalyzerPlugin(&#123;            analyzerMode: &#39;static&#39;, // html 文件方式输出编译分析            openAnalyzer: false,            reportFilename: path.resolve(__dirname, `analyzer/index.html`),          &#125;),        ],        [],      ),    ],  &#125;,&#125;;</code></pre><h3 id="扩展-react-hot-loader"><a href="#扩展-react-hot-loader" class="headerlink" title="扩展 react-hot-loader"></a>扩展 react-hot-loader</h3><blockquote><p>CRA v4.0 开始已经内置了 fast refresh —— <a href="https://github.com/facebook/create-react-app/releases/tag/v4.0.0">https://github.com/facebook/create-react-app/releases/tag/v4.0.0</a> ，不必自己扩展 hot loader。</p></blockquote><p>常用的热更新方案 react-hot-loader，craco 提供了专门的 craco plugin（<a href="https://github.com/HasanAyan/craco-plugin-react-hot-reload">传送门</a>），配置如下：</p><pre><code class="sh">yarn add craco-plugin-react-hot-reload -D</code></pre><pre><code class="js">/* craco.config.js */const &#123; whenDev, whenProd, when &#125; = require(&#39;@craco/craco&#39;);const reactHotReloadPlugin = require(&#39;craco-plugin-react-hot-reload&#39;);module.exports = &#123;  babel: &#123;&#125;,  webpack: &#123;&#125;,  // craco 提供的插件  plugins: [    // 新增 craco-plugin-react-hot-reload    ...whenDev(      () =&gt; [        &#123;          plugin: reactHotReloadPlugin,        &#125;,      ],      [],    ),  ],&#125;;</code></pre><p>添加完配置，还需在入口文件中修改一下 render。</p><pre><code class="sh">yarn add react-hot-loader -D</code></pre><pre><code class="js">/* 入口 index.ts */import React from &#39;react&#39;import ReactDOM from &#39;react-dom&#39;+ import &#123; hot &#125; from &#39;react-hot-loader&#39;+ import &#123; isDev &#125; from &#39;@/utils&#39; // isDev 你可以自己编写定义，例如：const isDev = process.env.NODE_ENV === &#39;development&#39;import App from &#39;./App&#39;+ const Root = isDev ? hot(module)(App) : App- ReactDOM.render(&lt;App /&gt;, document.getElementById(&#39;root&#39;))+ ReactDOM.render(&lt;Root /&gt;, document.getElementById(&#39;root&#39;))</code></pre><h3 id="比-react-hot-loader-更好的方案-craco-fast-refresh"><a href="#比-react-hot-loader-更好的方案-craco-fast-refresh" class="headerlink" title="比 react-hot-loader 更好的方案 craco-fast-refresh"></a>比 react-hot-loader 更好的方案 craco-fast-refresh</h3><blockquote><p>CRA v4.0 开始已经内置了 fast refresh —— <a href="https://github.com/facebook/create-react-app/releases/tag/v4.0.0">https://github.com/facebook/create-react-app/releases/tag/v4.0.0</a> ，不必自己扩展 hot loader。</p></blockquote><p>这是最近发现的新 craco plugin，相对于 react-hot-loader 好用得多，零配置，不需要修改项目代码，据说性能也更好。</p><pre><code class="sh">yarn add craco-fast-refresh -D</code></pre><pre><code class="js">/* craco.config.js */const &#123; whenDev &#125; = require(&#39;@craco/craco&#39;);const fastRefreshCracoPlugin = require(&#39;craco-fast-refresh&#39;);module.exports = &#123;  babel: &#123;&#125;,  webpack: &#123;&#125;,  // craco 提供的插件  plugins: [    ...whenDev(      () =&gt; [        &#123;          plugin: fastRefreshCracoPlugin,        &#125;,      ],      [],    ),  ],&#125;;</code></pre><h3 id="AntDesign-自定义主题-amp-按需加载"><a href="#AntDesign-自定义主题-amp-按需加载" class="headerlink" title="AntDesign 自定义主题 &amp; 按需加载"></a>AntDesign 自定义主题 &amp; 按需加载</h3><ul><li>在 bebel 配置中新增 <code>babel-plugin-import</code>，搞定 AntDesign 按需加载</li><li>新增 craco 提供的 plugin <code>craco-less</code>，搞定自定义主题</li></ul><pre><code class="sh">yarn add babel-plugin-import craco-less -D</code></pre><pre><code class="js">/* craco.config.js */const CracoLessPlugin = require(&#39;craco-less&#39;);module.exports = &#123;  babel: &#123;    plugins: [      // 配置 babel-plugin-import      [        &#39;import&#39;,        &#123;          libraryName: &#39;antd&#39;,          libraryDirectory: &#39;es&#39;,          style: &#39;css&#39;,        &#125;,        &#39;antd&#39;,      ],    ],  &#125;,  webpack: &#123;&#125;,  // craco 提供的插件  plugins: [    // 配置 less    &#123;      plugin: CracoLessPlugin,      options: &#123;        lessLoaderOptions: &#123;          lessOptions: &#123;            modifyVars: &#123;              // 自定义主题（如果有需要，单独文件定义更好一些）              &#39;@primary-color&#39;: &#39;#1DA57A&#39;,            &#125;,            javascriptEnabled: true,          &#125;,        &#125;,      &#125;,    &#125;,  ],&#125;;</code></pre><p>craco 也提供了专门的 plugin 来处理 antd 的集成（<a href="https://github.com/DocSpring/craco-antd">传送门</a>），与上方的配置方式有区别。从 github 的介绍中能够看到如下介绍：</p><p>craco-antd includes:</p><ul><li>Less (provided by craco-less)</li><li>babel-plugin-import to only import the required CSS, instead of everything</li><li>An easy way to customize the theme. Set your custom variables in ./antd.customize.less</li></ul><p>相对来讲使用会更简洁一些，推荐使用。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>经过项目中的试用，确实能够在不 eject 弹出配置的情况下，自定义所有的 cra 构建配置，因此，在后续的编码中，我应该还会继续使用。</p><p>上方是最近在项目中，使用到的一些配置，更多的使用方式建议通过阅读官方的文档（<a href="https://github.com/gsoft-inc/craco/blob/master/packages/craco/README.md">传送门</a>）去了解，尤其需要详细了解 craco.config.js 文件的配置列表（<a href="https://github.com/gsoft-inc/craco/blob/master/packages/craco/README.md#configuration-overview">Configuration Overview</a>）。</p><p>有几点建议如下：</p><ol><li><p>craco 有提供一些好用的 plugin（<a href="https://github.com/gsoft-inc/craco#community-maintained-plugins">传送门</a>），推荐优先考虑使用现成的插件去解决问题。</p><p>注意 craco 的 plugin 与 webpack plugin 不是同一概念，二者配置的位置也不同。</p></li><li><p>webpack 相关的配置覆盖，优先使用 craco 提供的快捷方式去配置。</p><p>解决不了的问题，在 configure 函数中配置，并且，推荐 configure 使用函数形式，而非对象形式。虽然，函数形式更复杂了一点，但是二者是互斥的，只好选择其中一种。</p></li></ol><p>最后，这里（ ☞ <a href="https://github.com/eleven-net-cn/create-react-app/blob/master/packages/cra-template-typescript/template/craco.config.js">传送门</a> ）有一份完整的 craco.config.js 配置文件，方便参照。</p><p>版本是 webpack v4、create-react-app v4，其它不同的版本，可能需要略加调整。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;内置 craco 扩展配置的 CRA Template，可直接使用。&lt;br&gt;TS 版本：&lt;a href=&quot;https://www.npmjs.com/package/@eleven.fe/cra-template-typescript&quot;&gt;@elev</summary>
      
    
    
    
    <category term="React" scheme="https://blog.eleven.net.cn/categories/React/"/>
    
    
    <category term="create-react-app" scheme="https://blog.eleven.net.cn/tags/create-react-app/"/>
    
  </entry>
  
  <entry>
    <title>1px 细线实现</title>
    <link href="https://blog.eleven.net.cn/2020/08/26/css/border/"/>
    <id>https://blog.eleven.net.cn/2020/08/26/css/border/</id>
    <published>2020-08-26T12:26:13.000Z</published>
    <updated>2025-05-07T09:00:36.260Z</updated>
    
    <content type="html"><![CDATA[<p>采用缩放方案，单条边线好处理一点；如果需要四边都有边线，会有点麻烦，使用缩放方案，虽然可行，但是在部分设备上有间隙问题，建议放弃，或者使用 svg 来做 background-image。</p><p>以下是 less/sass 的简单实现示例。</p><h3 id="LESS-上边线-1px"><a href="#LESS-上边线-1px" class="headerlink" title="LESS 上边线 1px"></a>LESS 上边线 1px</h3><pre><code class="less">.border-top(@color) &#123;  position: relative;  &amp;:before &#123;    position: absolute;    top: 0;    left: 0;    content: &#39;\0020&#39;;    width: 100%;    height: 1px;    border-top: 1px solid @color;    transform-origin: 0 0;    overflow: hidden;  &#125;  @media (-webkit-min-device-pixel-ratio: 1.5) and (-webkit-max-device-pixel-ratio: 2.49) &#123;    &amp;:before &#123;      transform: scaleY(0.5);    &#125;  &#125;  @media (-webkit-min-device-pixel-ratio: 2.5) &#123;    &amp;:before &#123;      transform: scaleY(0.33333);    &#125;  &#125;&#125;// 使用.test &#123;  .border-top(#eee);&#125;</code></pre><h3 id="SASS-上下-1px-细线"><a href="#SASS-上下-1px-细线" class="headerlink" title="SASS 上下 1px 细线"></a>SASS 上下 1px 细线</h3><pre><code class="scss">/** * 1px细线 *  $position top/bottom */@mixin border-1px($position, $color) &#123;  position: relative;  &amp;:before &#123;    position: absolute;    @if $position == top &#123;      top: 0;    &#125;    @if $position == bottom &#123;      bottom: 0;    &#125;    left: 0;    content: &#39;\0020&#39;;    width: 100%;    height: 1px;    border-#&#123;$position&#125;: 1px solid $color;    transform-origin: 0 0;    overflow: hidden;  &#125;  @media (-webkit-min-device-pixel-ratio: 1.5) and (-webkit-max-device-pixel-ratio: 2.49) &#123;    &amp;:before &#123;      transform: scaleY(0.5);    &#125;  &#125;  @media (-webkit-min-device-pixel-ratio: 2.5) &#123;    &amp;:before &#123;      transform: scaleY(0.33333);    &#125;  &#125;&#125;// 使用.test &#123;  // 上边线  @include border-1px(top, #e9e9e9);  // 下边线  @include border-1px(bottom, #e9e9e9);&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;采用缩放方案，单条边线好处理一点；如果需要四边都有边线，会有点麻烦，使用缩放方案，虽然可行，但是在部分设备上有间隙问题，建议放弃，或者使用 svg 来做 background-image。&lt;/p&gt;
&lt;p&gt;以下是 less/sass 的简单实现示例。&lt;/p&gt;
&lt;h3 id=&quot;</summary>
      
    
    
    
    <category term="CSS3" scheme="https://blog.eleven.net.cn/categories/CSS3/"/>
    
    
    <category term="1px-border" scheme="https://blog.eleven.net.cn/tags/1px-border/"/>
    
  </entry>
  
  <entry>
    <title>模块间循环引用问题</title>
    <link href="https://blog.eleven.net.cn/2020/06/11/nodejs/circular-deps/"/>
    <id>https://blog.eleven.net.cn/2020/06/11/nodejs/circular-deps/</id>
    <published>2020-06-11T10:02:52.000Z</published>
    <updated>2025-05-07T09:00:36.260Z</updated>
    
    <content type="html"><![CDATA[<p>有时候可能会遇见这样的场景：模块A引用了模块B里的func1方法，而模块B又引用了模块A里的func2方法。</p><p>类似上面的场景，或者其它更复杂的如：A 引用 B，B 引用 C，C 又引用了 A，在不经意间可能会遇到一些诡异问题，如：明明代码没问题，却读不到导入的模块……</p><p>为了更好地避免这样的问题，可以使用 <a href="https://github.com/aackerman/circular-dependency-plugin">circular-dependency-plugin</a> 插件来做循环引用的检测:</p><p>基本用法如下，复制、粘贴即可生效：</p><pre><code class="js">// webpack.config.jsconst CircularDependencyPlugin = require(&#39;circular-dependency-plugin&#39;)module.exports = &#123;  plugins: [    new CircularDependencyPlugin(&#123;      // exclude detection of files based on a RegExp      exclude: /node_modules/,      // include specific files based on a RegExp      include: /src/,      // add errors to webpack instead of warnings      failOnError: true,      // allow import cycles that include an asyncronous import,      // e.g. via import(/* webpackMode: &quot;weak&quot; */ &#39;./file.js&#39;)      allowAsyncCycles: false,      // set the current working directory for displaying module paths      cwd: process.cwd(),    &#125;)  ]&#125;</code></pre><p>检测到问题时，会看到如下图的编译提示：</p><p><img src="https://user-gold-cdn.xitu.io/2019/12/10/16eefa622ebb1ebf?w=1060&h=230&f=png&s=51565" alt=""></p><p>如何解决循环引用的问题？将被循环引用到的模块提取放到另外的模块，打破这个循环即可！</p><h4 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h4><ol><li><a href="https://www.imooc.com/article/260265">webpack 与循环引用</a></li><li><a href="http://www.ruanyifeng.com/blog/2015/11/circular-dependency.html">JavaScript 模块的循环加载</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有时候可能会遇见这样的场景：模块A引用了模块B里的func1方法，而模块B又引用了模块A里的func2方法。&lt;/p&gt;
&lt;p&gt;类似上面的场景，或者其它更复杂的如：A 引用 B，B 引用 C，C 又引用了 A，在不经意间可能会遇到一些诡异问题，如：明明代码没问题，却读不到导入的</summary>
      
    
    
    
    <category term="NodeJS" scheme="https://blog.eleven.net.cn/categories/NodeJS/"/>
    
    
    <category term="Webpack" scheme="https://blog.eleven.net.cn/tags/Webpack/"/>
    
    <category term="NodeJS" scheme="https://blog.eleven.net.cn/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>自动修改 node_moduels 源码</title>
    <link href="https://blog.eleven.net.cn/2020/06/11/nodejs/patch-package/"/>
    <id>https://blog.eleven.net.cn/2020/06/11/nodejs/patch-package/</id>
    <published>2020-06-11T02:23:01.000Z</published>
    <updated>2025-05-07T09:00:36.260Z</updated>
    
    <content type="html"><![CDATA[<p>有时候 node_modules 中的第三方包有问题或需要修改几行源码，我们可以怎么办？</p><ol><li><p>去给作者提 issues？可能得不到回复。</p></li><li><p>自己在 node_modules 里直接修改源码？下一次重新安装包，或者其他同事 install 的时候，被修改过的源码又恢复如初了。</p></li><li><p>不用他的包，自己写一个？……</p></li></ol><p>社区提供了一个工具：<a href="https://github.com/ds300/patch-package">patch-package</a>，专门用来处理修改 node_modules 包源码的问题。</p><h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><p>使用方法如下，注意 yarn、npm 使用时的差异，推荐使用 yarn。</p><ol><li><p>安装 patch-package</p><pre><code class="sh"># yarn 需要多安装一个包 postinstall-postinstall，https://github.com/ds300/patch-package#why-use-postinstall-postinstall-with-yarnyarn add patch-package postinstall-postinstall -D# or# npmnpm i patch-package -D</code></pre></li><li><p>在 package.json 的 scripts 中增加如下命令：</p><pre><code class="json">&quot;scripts&quot;: &#123;+  &quot;postinstall&quot;: &quot;patch-package&quot;&#125;</code></pre><p><code>postinstall</code> 是 npm 的钩子，会在依赖包被 <code>install</code> 之后被执行。</p></li><li><p>上面两步都做了，就可以去修改 node_modules 里任意第三方包的源码了。</p></li><li><p>修改了源码，随后需要执行以下命令：</p><pre><code class="sh"># [package-name] 是包名，不需要写路径。yarn patch-package [package-name]# ornpx patch-package [package-name]</code></pre><p>命令执行成功后，会发现项目根目录下多了一个文件夹 <code>patches</code>，该目录下多了文件，即为记录源码修改的文件。</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/27/1711bce8d8e01745?imageView2/0/w/1280/h/960/format/webp/ignore-error/1" alt=""></p><p>将 <code>patches</code> 目录及文件，通过 git 提交到代码仓库。</p></li><li><p>Over，后续其他同学不需要做额外操作，直接安装即可，node_modules 下的源码修改会自动更新。</p><p>之前已经安装过该第三方包的同学，需要卸载，重新安装一次。</p></li><li><p>如果后续还有其它包也需要修改源码，修改过后，再执行一次命令：</p><pre><code class="sh">yarn patch-package [package-name]# ornpx patch-package [package-name]</code></pre></li></ol><h2 id="直接提交-issues"><a href="#直接提交-issues" class="headerlink" title="直接提交 issues"></a>直接提交 issues</h2><p>完成上述步骤后，你甚至可以通过一行命令向第三方包提交 issues。</p><p>示例截图：</p><p><img src="/imgs/patch_pkg_create_issues.png" alt=""></p><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ol><li><p>过程中遇到一个错误，记录一下，其他人不一定会遇到。</p><p>macos 在终端报如下错误:</p><p><img src="https://user-gold-cdn.xitu.io/2020/3/27/1711bcf316c96916?w=2240&h=288&f=png&s=90956" alt=""></p><p>可以参照这个文档解决：<a href="https://www.cnblogs.com/start-fxw/p/10192226.html">https://www.cnblogs.com/start-fxw/p/10192226.html</a></p><p>终端运行如下命令：</p><pre><code class="bash">xcode-select --install</code></pre><p>更新一下 xcode 即可。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有时候 node_modules 中的第三方包有问题或需要修改几行源码，我们可以怎么办？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;去给作者提 issues？可能得不到回复。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自己在 node_modules 里直接修改源码？下一次重新安装包，或者其</summary>
      
    
    
    
    <category term="NPM" scheme="https://blog.eleven.net.cn/categories/NPM/"/>
    
    
    <category term="NPM" scheme="https://blog.eleven.net.cn/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>NPM 包发布指南</title>
    <link href="https://blog.eleven.net.cn/2020/05/10/npm/publish/"/>
    <id>https://blog.eleven.net.cn/2020/05/10/npm/publish/</id>
    <published>2020-05-10T02:21:34.000Z</published>
    <updated>2025-05-07T09:00:36.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ol><li><p>在 NPM 官网注册账号，<a href="https://www.npmjs.com">https://www.npmjs.com</a></p><p>邮件验证的时候可能需要翻墙访问。</p></li><li><p>本机安装 nodejs</p></li><li><p>推荐也安装一下 nrm，方便随时切换 npm 源</p><pre><code class="sh">sudo npm i nrm -g</code></pre><p>nrm 常用命令</p><pre><code class="sh">nrm ls                  # 查看所有nrm use [目标源]         # 切换至目标源</code></pre></li></ol><h2 id="package-json-文件"><a href="#package-json-文件" class="headerlink" title="package.json 文件"></a>package.json 文件</h2><p>包的<strong>根目录</strong>需要有一个 package.json 文件，可以通过 <code>npm init</code> 命令去创建，示例如下：</p><pre><code class="json">&#123;  &quot;name&quot;: &quot;@eleven.fe/reset.css&quot;,  &quot;version&quot;: &quot;1.0.6&quot;,  &quot;description&quot;: &quot;H5 网页 reset 方案，PC&amp;mobile&quot;,  &quot;main&quot;: &quot;lib/reset.css&quot;,  &quot;scripts&quot;: &#123;    &quot;release&quot;: &quot;npm publish . --access=public&quot;  &#125;,  &quot;repository&quot;: &#123;    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;git+https://github.com/eleven-net-cn/reset.css.git&quot;  &#125;,  &quot;keywords&quot;: [&quot;reset.css&quot;],  &quot;author&quot;: &quot;Eleven&quot;,  &quot;license&quot;: &quot;ISC&quot;,  &quot;bugs&quot;: &#123;    &quot;url&quot;: &quot;https://github.com/eleven-net-cn/reset.css/issues&quot;  &#125;,  &quot;homepage&quot;: &quot;https://github.com/eleven-net-cn/reset.css#readme&quot;,  &quot;files&quot;: [&quot;lib&quot;, &quot;ReadMe.md&quot;]&#125;</code></pre><p><strong>重点注意以下几项：</strong></p><ol><li><p>main：指定包的入口文件</p></li><li><p>name：指定包名</p><ul><li>发布之前都要去<a href="https://www.npmjs.com">NPM 官网</a>上搜索一遍，确认想要使用的包名，是否已经被占用。</li><li>包名支持 [@scope]/[package name] 的形式，[@scope] 类似于命名空间的作用，NPM 默认允许你使用自己注册的用户名，或者在自己的账户下申请的 organizations。<br>典型的例子，如 Babel，插件原先使用的是 babel-plugin-xxx 的格式命名，后来因为许多个人发布的包和官方的包命名格式一样，导致难以区分，现在 babel 官方所有的包都更换成了 @babel/xxx 的格式。</li></ul></li><li><p>version：包的版本</p><ul><li>格式 <code>数字.数字.数字</code>，每一次发布，版本都必须要更新，只能往上增加。</li></ul></li><li><p>keywords：关键词</p><ul><li>希望别人通过哪些关键词搜索到你的包，可以在这里添加。</li></ul></li><li><p>files：指定哪些文件夹、文件将被发布</p><ul><li><p>如果你的项目目录下包含了一些隐私文件，不希望被发布出去，一定要注意配置此项，仅包含可以被发布的文件夹、文件。</p></li><li><p>可以在包的根目录下新建文件 <code>.npmignore</code>，指定哪些文件不被发布，书写格式与 <code>.gitignore</code> 文件一致。</p></li></ul></li><li><p>license：协议，推荐阅读了解几种开源的协议：</p><ul><li><p><a href="https://www.jianshu.com/p/86251523e898">七种开源许可证</a></p></li><li><p><a href="https://spdx.org/licenses/">SPDX License List</a></p></li></ul></li><li><p>description、repository、author、bugs、homepage 等项，通常也推荐填写完整，详细的 package.json 每一项的含义，推荐阅读这一篇：<a href="https://blog.csdn.net/zhengxiuchen86/article/details/81285030">npm package.json 属性详解</a> 。</p></li></ol><h2 id="待发布的包结构"><a href="#待发布的包结构" class="headerlink" title="待发布的包结构"></a>待发布的包结构</h2><ol><li><p>移除不必要的代码</p><p>发布出去的包，一般只需要包含用户使用时必须要 <code>install</code> 下载的文件即可，例如一些构建脚本等无关的代码文件，不必发布出去。</p><p>例如：你有一个开源项目，同时，该项目也提供了包供开发者使用，最佳方式应该是将该项目源码推送到 GitHub 上开源，而发布到 NPM 仓库的包，尽量不要把项目源码目录、构建脚本等非必要的文件发布到 NPM 仓库，会增大包的体积，导致安装时间变长。</p></li><li><p>发布的包尽量要做好语法转译，否则要在文档中说明，提醒使用者自己完成。</p></li><li><p>保护隐私</p><p>如果待发布的包，并非开源项目，而仅仅是为了提供开发者 NPM 安装、使用，一定要做好隐私保护工作，防止源码、隐私的文档等隐秘信息被发布到 NPM 仓库。</p><p>可以选用的方法如下：</p><ol><li><p><code>.gitignore</code> 设置忽略哪些文件</p><p>.gitignore 设置的忽略文件，在 git 代码管理和 npm publish 都会被忽略。</p></li><li><p>.npmignore 设置忽略哪些文件</p><p>.npmignore 优先级更高，如果同时使用了 .npmignore 和 .gitignore，只有 .npmignore 会生效。</p></li><li><p>package.json 文件的 files 字段</p><p>直接在 package.json 文件中配置 <code>files</code>，指定发布哪些文件、目录，优先级高于 .npmignore 和 .gitignore。</p></li></ol></li><li><p>以下文件、目录在发布时，默认会被忽略</p><pre><code class="txt">.*.swp._*.DS_Store.git.hg.npmrc.lock-wscript.svn.wafpickle-*config.gypiCVSnpm-debug.lognode_modules/</code></pre></li><li><p>以下文件、目录在发布时，默认会被包含，无法忽略掉</p><pre><code class="txt">package.jsonREADME (and its variants)CHANGELOG (and its variants)LICENSE / LICENCE</code></pre></li></ol><h2 id="正式发布"><a href="#正式发布" class="headerlink" title="正式发布"></a>正式发布</h2><ol><li><p>登录 NPM 账号</p><ol><li><p>在终端运行命令，填写账号、密码及邮箱。</p><pre><code class="sh">npm adduser / npm login</code></pre></li><li><p>查看是否登录上了？</p><pre><code class="sh">npm who am i</code></pre></li><li><p>通常只有一个人可以发布，也可以添加多人，相关命令如下：</p><pre><code class="sh">npm owner ls &lt;package name&gt;             # 查看npm owner add &lt;user&gt; &lt;package name&gt;     # 添加npm owner rm &lt;user&gt; &lt;package name&gt;      # 删除</code></pre></li></ol></li><li><p>发布</p><pre><code class="sh">npm publish . --access=public</code></pre><ol><li><p>这里注意一下发布命令中的点 <code>.</code> ，如果不带 <code>.</code> ，偶尔碰到发布会出错。</p></li><li><p>包名重复（或者说已被占用）、未登录，都会导致发布失败，注意看提示信息。</p></li><li><p>注意版本号必须要递增，相同的版本号或版本号递减会发布失败。</p></li></ol></li></ol><h2 id="撤回已发布的版本"><a href="#撤回已发布的版本" class="headerlink" title="撤回已发布的版本"></a>撤回已发布的版本</h2><pre><code class="sh">npm unpublish -f &lt;package name&gt;@&lt;package version&gt;</code></pre><ol><li><p>包发布后的 72 小时内，可以撤回。</p></li><li><p>已撤回的版本，该版本号就不能再重新发布了，因为在 NPM 的仓库中已经有了记录。</p></li></ol><h2 id="其它问题"><a href="#其它问题" class="headerlink" title="其它问题"></a>其它问题</h2><ol><li><p>偶尔可能会看到如下错误:</p><pre><code class="sh">no_perms Private mode enable, only admin can publish this module</code></pre><p>解决办法：</p><pre><code class="sh">npm config set registry http://registry.npmjs.org</code></pre></li><li><p>NPM 官方提供了发布的指导：<a href="https://docs.npmjs.com/misc/developers">https://docs.npmjs.com/misc/developers</a> ，如果遇到一些奇怪的问题，建议前往阅读。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;准备工作&quot;&gt;&lt;a href=&quot;#准备工作&quot; class=&quot;headerlink&quot; title=&quot;准备工作&quot;&gt;&lt;/a&gt;准备工作&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;p&gt;在 NPM 官网注册账号，&lt;a href=&quot;https://www.npmjs.com&quot;&gt;https://</summary>
      
    
    
    
    <category term="NPM" scheme="https://blog.eleven.net.cn/categories/NPM/"/>
    
    
    <category term="NPM" scheme="https://blog.eleven.net.cn/tags/NPM/"/>
    
  </entry>
  
  <entry>
    <title>规范 git commit</title>
    <link href="https://blog.eleven.net.cn/2020/03/25/git/commit/"/>
    <id>https://blog.eleven.net.cn/2020/03/25/git/commit/</id>
    <published>2020-03-25T02:17:53.000Z</published>
    <updated>2025-05-07T09:00:36.260Z</updated>
    
    <content type="html"><![CDATA[<p>如何让 <code>git commit</code> 提交时更加规范？例如：vue、angular，如下图。规范化地提交记录，会让将来的回溯查找更容易，也让其他人阅读起来更加简便。</p><p><img src="https://user-gold-cdn.xitu.io/2020/5/12/172081ff77566188?w=996&h=1021&f=png&s=251160" alt=""></p><p>最近读到一篇不错的文章（<a href="https://juejin.im/post/5e0c82a15188253a907111dc">你可能已经忽略的 git commit 规范</a>），吸取下养分，顺便做个记录。文章介绍得很清楚，建议阅读原文，不做额外赘述，以下为集成到项目的快速指南。</p><h2 id="快速指南"><a href="#快速指南" class="headerlink" title="快速指南"></a>快速指南</h2><p>使用到的工具 <a href="https://github.com/commitizen/cz-cli">commitizen</a>、<a href="https://github.com/typicode/husky">husky</a>、<a href="https://github.com/carloscuesta/gitmoji-cli">gitmoji-cli</a>，cz-conventional-changelog 是 angular 的 commit message 格式。</p><p>所有包不推荐 global 安装，而仅项目本地安装，方便多人开发时，减少其他人的额外操作。</p><ol><li><p>安装工具</p><pre><code class="bash"> yarn add commitizen cz-conventional-changelog -D</code></pre></li><li><p>在项目根目录的 package.json 中添加配置</p><pre><code class="json"> &#123;   &quot;scripts&quot;: &#123;     &quot;commit&quot;: &quot;git-cz&quot;   &#125;,   &quot;config&quot;: &#123;     &quot;commitizen&quot;: &#123;       &quot;path&quot;: &quot;./node_modules/cz-conventional-changelog&quot;     &#125;   &#125; &#125;</code></pre><p> 官方推荐的是 global 安装 commitizen，然后执行 <code>commitizen init cz-conventional-changelog --yarn --dev --exact</code> 去自动添加 cz-conventional-changelog，自动在 package.json 中添加 config 配置，不太推荐这种方式。</p></li><li><p>使用</p><ul><li><p><code>git commit</code> 仍然是普通的 git 提交模式</p></li><li><p><code>yarn commit</code> 会执行交互式 commit 提交，在终端跟着提示一步步输入即可。</p></li></ul></li><li><p>限制每一次 <code>git commit</code> 都执行交互式提交</p><p> 如果想要更暴力一点，限制每一次 <code>git commit</code> 都自动执行规范化地提交，可以配置 git 提交的钩子，借助 husky 更方便一点（不用 husky 当然也可以）。</p><p> 先将 scripts 中配置的 commit 命令删除，不再需要了。</p><p> 安装 husky</p><pre><code class="bash"> yarn add husky -D</code></pre><p> 在 package.json 中增加配置</p><pre><code class="json"> &#123;   &quot;husky&quot;: &#123;     &quot;hooks&quot;: &#123;       &quot;prepare-commit-msg&quot;: &quot;exec &lt; /dev/tty &amp;&amp; git cz --hook || true&quot;     &#125;   &#125;, &#125;</code></pre><p> 有些时候可能不太需要所有的 commit 都执行规范化的提交流程，因此，推荐不要这么暴力限制，而是仅在关键性的提交步骤才执行。</p></li></ol><h2 id="在提交中支持表情符号"><a href="#在提交中支持表情符号" class="headerlink" title="在提交中支持表情符号"></a>在提交中支持表情符号</h2><p>如果想要在提交中使用一些表情符号，如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/5/12/172086dbf52c646f?w=2016&h=1570&f=png&s=405106" alt=""></p><p>在提交时按照约定格式输入表情字符即可（左右两边英文冒号夹着字符，例如bug ☞ <code>:bug:</code>），提交后会自动被显示（而无需安装<a href="https://github.com/carloscuesta/gitmoji-cli">gitmoji-cli</a>等工具），示例：</p><pre><code class="bash">git commit -m &quot;fix(src): :bug: 修复列表显示问题&quot;</code></pre><p>如果想要查看所有的表情符号及介绍，可以<a href="https://gitmoji.carloscuesta.me/">去官方文档查阅</a>。</p><h2 id="常见的-commit-类型"><a href="#常见的-commit-类型" class="headerlink" title="常见的 commit 类型"></a>常见的 commit 类型</h2><ul><li>feat: 新增feature</li><li>fix: 修复bug</li><li>docs: 仅仅修改了文档，如readme.md</li><li>style: 仅仅是对格式进行修改，如逗号、缩进、空格等。不改变代码逻辑。</li><li>refactor: 代码重构，没有新增功能或修复bug</li><li>perf: 优化相关，如提升性能、用户体验等。</li><li>test: 测试用例，包括单元测试、集成测试。</li><li>chore: 改变构建流程、或者增加依赖库、工具等。</li><li>revert: 版本回滚</li></ul><h2 id="手写-commit-的推荐写法"><a href="#手写-commit-的推荐写法" class="headerlink" title="手写 commit 的推荐写法"></a>手写 commit 的推荐写法</h2><p>如果通过简单的 git commit -m “” 提交，你大概可以这样写：</p><pre><code class="bash">git commit -m &quot;feat(player): 播放功能开发完成&quot;</code></pre><p>引号内即 commit 的 message:</p><ul><li>feat 表明本次提交的类型</li><li>括号内容是本次代码的影响目录/文件</li><li>冒号后面是本次提交的简短描述（冒号后面推荐来个空格）  </li></ul><p>加点表情符号（当然，你要先安装 gitmoji-cli）：</p><pre><code class="bash">git commit -m &quot;feat(player): :rocket: 播放功能开发完成&quot;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;如何让 &lt;code&gt;git commit&lt;/code&gt; 提交时更加规范？例如：vue、angular，如下图。规范化地提交记录，会让将来的回溯查找更容易，也让其他人阅读起来更加简便。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.i</summary>
      
    
    
    
    <category term="Git" scheme="https://blog.eleven.net.cn/categories/Git/"/>
    
    
    <category term="Git" scheme="https://blog.eleven.net.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Git Hook 提交时修改版本号</title>
    <link href="https://blog.eleven.net.cn/2020/03/12/nodejs/check-version/"/>
    <id>https://blog.eleven.net.cn/2020/03/12/nodejs/check-version/</id>
    <published>2020-03-12T02:07:48.000Z</published>
    <updated>2025-05-07T09:00:36.260Z</updated>
    
    <content type="html"><![CDATA[<p>前端项目在 Git 提交时，往往会遗忘更新项目根目录的 package.json 文件的 version，通常不修改也不会有啥问题，但对于强迫症来说，不能忍！咱要改掉它……</p><h4 id="编写一个简单的-node-脚本-check-version-js"><a href="#编写一个简单的-node-脚本-check-version-js" class="headerlink" title="编写一个简单的 node 脚本 check-version.js"></a>编写一个简单的 node 脚本 <code>check-version.js</code></h4><p>先安装几个依赖包 <code>yarn add inquirer chalk child_process -D</code></p><pre><code class="js">// /scripts/check-version.jsconst inquirer = require(&#39;inquirer&#39;);const chalk = require(&#39;chalk&#39;);const &#123; exec &#125; = require(&#39;child_process&#39;);const &#123; name: projectName, version: versionCurrent &#125; = require(&#39;../package&#39;);const regVersion = /^[1-9]&#123;1&#125;\d*\.\d+\.\d+$/; // 示例: 1.0.0// const regVersion = /^\d+\.\d+\.\d+$/ // 示例: 0.0.1 / 1.0.1// const regVersion = /^\d+\.\d+\.\d+(-beta.?\d*)?$/ // 示例: 1.0.3 / 0.0.1-beta / 1.0.0-beta.3console.log(&#39;\n&#39;);// 确认 package.json 版本号inquirer  .prompt([    &#123;      type: &#39;input&#39;,      name: &#39;version&#39;,      message: `请确认 $&#123;projectName&#125;/package.json/version 版本号（当前：$&#123;versionCurrent&#125;）：\n`,      default: versionCurrent,      validate(version) &#123;        // 校验版本号的格式        if (!regVersion.test(version)) &#123;          console.log(chalk.yellow(&#39;输入的版本号无效，请检查格式（示例：1.0.0、2.3.2）&#39;));          return false;        &#125;        return true;      &#125;,    &#125;,  ])  .then((&#123; version: versionNew &#125;) =&gt; &#123;    if (versionNew !== versionCurrent) &#123;      // 更新 package.json version，更新时不自动生成 tag      command(`npm --no-git-tag-version version $&#123;versionNew&#125;`, &#123;&#125;, (error, stdout, stderr) =&gt; &#123;        if (!error) &#123;          console.log(            chalk.green(              `\n$&#123;projectName&#125; 版本号（项目根目录下的 package.json/version）更新成功，version: $&#123;versionNew&#125; ！`,            ),          );          command(            `git add package.json &amp;&amp; git commit -m &#39;ci(package.json): 更新项目版本号为：$&#123;versionNew&#125;&#39;`,          );          console.log(`\n`);          process.exit(0);        &#125; else &#123;          console.log(chalk.yellow(`\n更新版本号（$&#123;versionNew&#125;）失败了~\n`));          process.exit(1);        &#125;      &#125;);    &#125; else &#123;      console.log(chalk.green(`\n本次版本号未做修改，version: $&#123;versionNew&#125; ！\n`));    &#125;  &#125;);function command(cmd, options, callback) &#123;  console.log(&#39;\n&#39;);  console.log(chalk.cyan(cmd.toString()));  return exec(cmd, &#123; ...options &#125;, callback);&#125;</code></pre><h4 id="配置-Git-钩子"><a href="#配置-Git-钩子" class="headerlink" title="配置 Git 钩子"></a>配置 Git 钩子</h4><ol><li><p>先安装 <code>yorkie</code>，用于管理 git 钩子，当然，使用原生的也可以。</p><pre><code class="bash">yarn add yorkie -D</code></pre></li><li><p>在项目的 package.json 文件中增加以下配置：</p><pre><code class="json">&quot;gitHooks&quot;: &#123;  &quot;post-commit&quot;: &quot;exec &lt; /dev/tty &amp;&amp; node scripts/check-version.js&quot;&#125;,</code></pre></li></ol><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>完成以上配置后，后续在执行 git commit 提交代码时，会自动在终端弹出交互，提示修改 package.json 文件的 version，如下图：</p><p><img src="https://user-gold-cdn.xitu.io/2020/6/10/1729d6b37f7e5254?w=1326&h=348&f=png&s=55796" alt=""></p><p>如果不需要修改直接敲击 Enter 跳过，需要则输入新的版本号，会自动执行命令修改 package.json 文件的 version，并自动提交刚刚的修改，接下来 <code>git push</code> 推送代码即可。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;前端项目在 Git 提交时，往往会遗忘更新项目根目录的 package.json 文件的 version，通常不修改也不会有啥问题，但对于强迫症来说，不能忍！咱要改掉它……&lt;/p&gt;
&lt;h4 id=&quot;编写一个简单的-node-脚本-check-version-js&quot;&gt;&lt;a h</summary>
      
    
    
    
    <category term="NodeJS" scheme="https://blog.eleven.net.cn/categories/NodeJS/"/>
    
    
    <category term="Git" scheme="https://blog.eleven.net.cn/tags/Git/"/>
    
    <category term="NPM" scheme="https://blog.eleven.net.cn/tags/NPM/"/>
    
    <category term="NodeJS" scheme="https://blog.eleven.net.cn/tags/NodeJS/"/>
    
  </entry>
  
  <entry>
    <title>Git 命令清单</title>
    <link href="https://blog.eleven.net.cn/2020/03/02/git/command/"/>
    <id>https://blog.eleven.net.cn/2020/03/02/git/command/</id>
    <published>2020-03-02T04:12:29.000Z</published>
    <updated>2025-05-07T09:00:36.260Z</updated>
    
    <content type="html"><![CDATA[<p>Git 常用命令做一波整理，方便随时查阅。</p><blockquote><p>主要内容出自阮一峰大佬的科普文章：<a href="http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html</a> 。</p></blockquote><p><img src="https://www.ruanyifeng.com/blogimg/asset/2015/bg2015120901.png" alt=""></p><p>几个专用名词的译名如下：</p><ul><li>Workspace：工作区</li><li>Index / Stage：暂存区</li><li>Repository：仓库区（或本地仓库）</li><li>Remote：远程仓库</li></ul><h2 id="一、新建代码库"><a href="#一、新建代码库" class="headerlink" title="一、新建代码库"></a>一、新建代码库</h2><pre><code class="zsh"># 在当前目录新建一个 Git 代码库$ git init# 新建一个目录，将其初始化为 Git 代码库$ git init [project-name]# 下载一个项目和它的整个代码历史$ git clone [url]</code></pre><h2 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h2><p>Git 的设置文件为 <code>.gitconfig</code>，它可以在用户主目录下（全局配置），也可以在项目目录下（项目配置）。</p><pre><code class="zsh"># 显示当前的 Git 配置$ git config --list# 编辑 Git 配置文件$ git config -e [--global]# 设置提交代码时的用户信息(设置本机的用户名，邮箱)$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot;# 查看用户信息$ git config user.name -g$ git config user.email -g# 查看公开密钥$ cat ~/.ssh/id_rsa.pub# 验证密钥是否已连接成功(以 github 为例)$ ssh -T git@github.com# 创建 SSH Key$ ssh-keygen -t rsa -C &quot;youremail@example&quot;# 解决每次要求输入用户名/密码的问题$ git config --global credential.helper store# 设置 http 代理$ git config --global http.proxy 10.100.10.100:3128# 设置 Git 对文件/文件夹大小写敏感$ git config core.ignorecase false# 设置全局 pull rebase$ git config --global pull.rebase true# gitlab ip 变化后$ rm -rf ~/.ssh/known_hosts 删除后重新操作即可</code></pre><h2 id="三、增加-删除文件"><a href="#三、增加-删除文件" class="headerlink" title="三、增加/删除文件"></a>三、增加/删除文件</h2><pre><code class="zsh"># 添加指定文件到暂存区$ git add [file1] [file2] ...# 添加指定目录到暂存区，包括子目录$ git add [dir]# 添加当前目录的所有文件到暂存区$ git add .$ git add -A 添加所有文件# 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p# 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file]# 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed]</code></pre><h2 id="四、代码提交"><a href="#四、代码提交" class="headerlink" title="四、代码提交"></a>四、代码提交</h2><pre><code class="zsh"># 提交暂存区到仓库区$ git commit -m [message]# 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message]# 提交工作区自上次 commit 之后的变化，直接到仓库区$ git commit -a# 提交时显示所有 diff 信息$ git commit -v# 使用一次新的 commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次 commit 的提交信息$ git commit --amend -m [message]# 重做上一次 commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ...</code></pre><h2 id="五、分支"><a href="#五、分支" class="headerlink" title="五、分支"></a>五、分支</h2><pre><code class="zsh"># 有时候看不到远程的分支，那么更新下远程库的索引$ git fetch# 列出所有本地分支$ git branch# 列出所有远程分支$ git branch -r# 列出所有本地分支和远程分支$ git branch -a# 新建一个分支，但依然停留在当前分支$ git branch [branch-name]# 新建一个分支，并切换到该分支$ git checkout -b [branch]# 拉取一个本地不存在的新分支，并切换到该分支$ git checkout -b [branch-name] [origin/branch-name]# 新建一个分支，指向指定 commit$ git branch [branch] [commit]# 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch]# 切换到指定分支，并更新工作区$ git checkout [branch-name]# 切换到上一个分支$ git checkout -# 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch]# 合并指定分支到当前分支$ git merge [branch]# 选择一个 commit，合并进当前分支$ git cherry-pick [commit]# 删除分支$ git branch -d [branch-name]# 删除分支(如果要删除的分支，本地仓库有代码没有 push 到远程仓库，-d 是删不掉的，需要用-D; 切回去先 push 再删也行.)$ git branch -D [branch-name]# 批量删除本地分支（排除 master/develop/test 分支）$ git branch -a | grep -v -E &#39;master|develop|test&#39; | xargs git branch -D# 批量删除本地分支（仅包含 releases）$ git branch -a | grep &#39;releases&#39; | xargs git branch -D# 批量删除远程分支（排除 master/develop/test 分支）$ git branch -r| grep -v -E &#39;master|develop|test&#39; | sed &#39;s/origin\///g&#39; | xargs -I &#123;&#125; git push origin :&#123;&#125;# 批量删除远程分支（仅包含 releases）$ git branch -r| grep &#39;releases&#39; | sed &#39;s/origin\///g&#39; | xargs -I &#123;&#125; git push origin :&#123;&#125;# 重命名分支(不会覆盖已存在的同名分支)$ git branch -m [branch-name] [new-name]# 重命名分支(会覆盖已存在的同名分支)$ git branch -M [branch-name] [new-name]# 删除远程分支$ git push origin -d [branch-name] （将服务器上的“远程分支”删除，删除远程分支常用这个。）$ git branch -dr [remote/branch] （仅将本地的“远程分支”删除）# 处理已经不存在的分支（有时不存在了，但仍然显示）$ git remote show origin 查看远程库和分支的情况$ git remote prune origin 可以移除一些已经不存在的分支# 比较两个分支不同$ git diff [分支 A] [分支 B] &gt;&gt; xx.txt （比较两个分支不同，输出到某文本）</code></pre><h2 id="六、标签"><a href="#六、标签" class="headerlink" title="六、标签"></a>六、标签</h2><p>tag 对应某次 commit 节点，是一个点，是不可移动的。</p><p>branch 对应一系列 commit，是很多点连成的一根线，有一个 HEAD 指针，可以依靠 HEAD 指针移动。</p><p>两者的区别决定了使用方式，改动代码用 branch ，不改动只查看用 tag。</p><blockquote><p>tag 和 branch 的相互配合使用，有时候起到非常方便的效果，例如：已经发布了 v1.0、v2.0、v3.0 三个版本，这个时候，我突然想不改现有代码的前提下，在 v2.0 的基础上加个新功能，作为 v4.0 发布。就可以检出 v2.0 的代码作为一个 branch ，然后作为开发分支。</p></blockquote><pre><code class="zsh"># 列出所有 tag$ git tag# 新建一个 tag 在当前 commit$ git tag [tag]# 新建一个 tag，并加上注释说明$ git tag -a [tag-name] -m &quot;some words&quot;# 新建一个 tag 在指定 commit$ git tag [tag] [commit]# 删除本地 tag$ git tag -d [tag]# 删除远程 tag$ git push origin -d [tagName]$ git push origin :refs/tags/[tagName]# 查看 tag 信息$ git show [tag]# 提交指定 tag$ git push [remote] [tag]# 提交所有 tag$ git push [remote] --tags# 新建一个分支，指向某个 tag$ git checkout -b [branch] [tag]# 重命名 tag (新建 tag 指向原来的 tag =&gt; 再删除旧的 tag =&gt; 并删除远程旧 tag)$ git tag [new-tag-name] [old-tag-name]$ git tag -d [old-tag-name]$ git push [remote] -d [old-tag-name]</code></pre><h2 id="七、查看信息"><a href="#七、查看信息" class="headerlink" title="七、查看信息"></a>七、查看信息</h2><pre><code class="zsh"># 显示有变更的文件$ git status# 显示当前分支的版本历史$ git log# 显示 commit 历史，以及每次 commit 发生变更的文件$ git log --stat# 查看分支合并图$ git log --graph# 搜索提交历史，根据关键词$ git log -S [keyword]# 显示某个 commit 之后的所有变动，每个 commit 占据一行$ git log [tag] HEAD --pretty=format:%s# 显示某个 commit 之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature# 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file]# 显示指定文件相关的每一次 diff$ git log -p [file]# 显示过去 5 次提交$ git log -5 --pretty --oneline# 显示所有提交过的用户，按提交次数排序$ git shortlog -sn# 显示指定文件是什么人在什么时间修改过$ git blame [file]# 显示暂存区和工作区的差异$ git diff# 显示暂存区和上一个 commit 的差异$ git diff --cached [file]# 显示工作区与当前分支最新 commit 之间的差异$ git diff HEAD# 显示两次提交之间的差异$ git diff [first-branch]...[second-branch]# 显示今天你写了多少行代码$ git diff --shortstat &quot;@&#123;0 day ago&#125;&quot;# 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit]# 显示某次提交时，某个文件的内容$ git show [commit]:[filename]# 显示当前分支的最近几次提交$ git reflog</code></pre><h2 id="八、远程同步"><a href="#八、远程同步" class="headerlink" title="八、远程同步"></a>八、远程同步</h2><pre><code class="zsh"># 下载远程仓库的所有变动$ git fetch [remote]# 显示所有远程仓库$ git remote -v# 显示某个远程仓库的信息$ git remote show [remote]# 增加一个新的远程仓库(本地仓库与远程仓库建立连接)，并命名(别名)$ git remote add [shortname] [url]# 删除一个远程仓库$ git remote rm [shortname]# 远程仓库更名后，修改连接地址$ git remote set-url [shortname] [new-url]# 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch]# 上传本地指定分支到远程仓库$ git push [remote] [branch]# 推送分支到远程仓库(第一次需要-u，建立关系)$ git push -u [remote] [branch]# 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --forcegit push [remote] -f# 推送所有分支到远程仓库$ git push [remote] --all</code></pre><h2 id="九、撤销"><a href="#九、撤销" class="headerlink" title="九、撤销"></a>九、撤销</h2><h3 id="Checkout"><a href="#Checkout" class="headerlink" title="Checkout"></a>Checkout</h3><p>checkout，没有 add 到暂存区的，撤回到版本库的状态; 已 add 到暂存区未 commit，其后的修改，撤回到暂存区状态。</p><pre><code class="zsh"># 恢复暂存区的指定文件到工作区 (回退某文件到工作区)$ git checkout [file]# 恢复某个 commit 的指定文件到暂存区和工作区 (回退到未 commit 状态)$ git checkout [commit] [file]# 例如: git checkout 36393f5fc07e54f6704d23d4d92bf0b3773e523c xxx/main/src/util/eg.js# 恢复暂存区的所有文件到工作区 (回退所有文件到工作区)$ git checkout .</code></pre><h3 id="Reset"><a href="#Reset" class="headerlink" title="Reset"></a>Reset</h3><p>checkout 是撤销修改，reset 是在版本间穿梭。</p><pre><code class="zsh"># 重置指定文件到指定版本$ git reset [版本号] [文件路径(从顶层一路相对下来)]# 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变$ git reset [file]# 重置暂存区$ git reset HEAD# 重置暂存区与工作区，与上一次 commit 保持一致$ git reset --hard# 重置当前分支的指针为指定 commit，同时重置暂存区，但工作区不变$ git reset [commit]# 重置当前分支的 HEAD 为指定 commit，同时重置暂存区和工作区，与指定 commit 一致$ git reset --hard [commit] =&gt; 回退到某个版本$ git reset --hard HEAD~1 =&gt; 回退到上一个版本# 重置当前 HEAD 为指定 commit，但保持暂存区和工作区不变$ git reset --keep [commit]# 新建一个 commit，用来撤销指定 commit# 后者的所有变化都将被前者抵消，并且应用到当前分支# 适用场景： 如果我们想撤销之前的某一版本，但是又想保留该目标版本后面的版本，记录下这整个版本变动流程，就可以用这种方法。$ git revert [commit]</code></pre><p>Reset 和 Revert 的对比：<a href="https://blog.csdn.net/yxlshk/article/details/79944535">https://blog.csdn.net/yxlshk/article/details/79944535</a></p><h3 id="Stash"><a href="#Stash" class="headerlink" title="Stash"></a>Stash</h3><p>stash 可用于临时解决 bug 时，将眼前的工作隐藏；随后切换到解决 bug 的分支，完成 bug，提交，合并；<br>回到原先工作的分支，查看隐藏，恢复；over!</p><pre><code class="zsh"># 暂时将未提交的变化移除(隐藏工作现场)$ git stash# 将移除的移入(恢复工作现场)，同时之前 stash 的内容也即删除了(不想删除，请用 apply 命令)$ git stash pop# 查看所有隐藏的工作现场$ git stash list# 恢复 XX，同时把 stash 内容删除$ git stash pop XX# 恢复 xx 但 stash 内容不删除$ git stash apply XX# 删除 XX$ git stash drop XX</code></pre><h2 id="十、其他"><a href="#十、其他" class="headerlink" title="十、其他"></a>十、其他</h2><pre><code class="zsh"># 生成一个可供发布的压缩包$ git archive# 停止追踪某文件，并保留在本地$ git rm --cached XXXX# 停止追踪某文件，并删除本地文件$ git rm --f XXXX</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Git 常用命令做一波整理，方便随时查阅。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;主要内容出自阮一峰大佬的科普文章：&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html&quot;&gt;http://w</summary>
      
    
    
    
    <category term="Git" scheme="https://blog.eleven.net.cn/categories/Git/"/>
    
    
    <category term="Git" scheme="https://blog.eleven.net.cn/tags/Git/"/>
    
  </entry>
  
</feed>
